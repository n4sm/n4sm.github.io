<!DOCTYPE html>


<html theme="dark" showBanner="true" hasBanner="true" > 
<link href="/fontawesome/css/fontawesome.css" rel="stylesheet">
<link href="/fontawesome/css/brands.css" rel="stylesheet">
<link href="/fontawesome/css/solid.css" rel="stylesheet">
<script src="/js/color.global.min.js" ></script>
<script src="/js/load-settings.js" ></script>
<head>
  <meta charset="utf-8">
  
  
  

  
  <title>Linux kernel side notes | repr</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="preload" href="/css/fonts/Roboto-Regular.ttf" as="font" type="font/ttf" crossorigin="anonymous">
  <link rel="preload" href="/css/fonts/Roboto-Bold.ttf" as="font" type="font/ttf" crossorigin="anonymous">
  <link rel="preload" href="/css/fonts/MaterialSymbolsRounded.woff2" as="font" type="font/woff2" crossorigin="anonymous">

  <meta name="description" content="Here are just some side notes about linux kernel internals I put here to avoid to have to learn same things again and again. Every notes target linux kernel 5.18.12.There will be a lot of code for whi">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux kernel side notes">
<meta property="og:url" content="https://n4sm.github.io/posts/lowlevelnotes/index.html">
<meta property="og:site_name" content="repr">
<meta property="og:description" content="Here are just some side notes about linux kernel internals I put here to avoid to have to learn same things again and again. Every notes target linux kernel 5.18.12.There will be a lot of code for whi">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://n4sm.github.io/SLUB_schema1.png">
<meta property="article:published_time" content="2022-07-17T22:00:00.000Z">
<meta property="article:modified_time" content="2023-09-05T09:45:11.052Z">
<meta property="article:author" content="nasm">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://n4sm.github.io/SLUB_schema1.png">
  
    <link rel="alternate" href="/atom.xml" title="repr" type="application/atom+xml">
  
  
    <link rel="icon" media="(prefers-color-scheme: light)" href="/images/favicon-light-32.png" sizes="32x32">
    <link rel="icon" media="(prefers-color-scheme: light)" href="/images/favicon-light-128.png" sizes="128x128">
    <link rel="icon" media="(prefers-color-scheme: light)" href="/images/favicon-light-180.png" sizes="180x180">
    <link rel="icon" media="(prefers-color-scheme: light)" href="/images/favicon-light-192.png" sizes="192x192">
    <link rel="icon" media="(prefers-color-scheme: dark)" href="/images/favicon-dark-32.png" sizes="32x32">
    <link rel="icon" media="(prefers-color-scheme: dark)" href="/images/favicon-dark-128.png" sizes="128x128">
    <link rel="icon" media="(prefers-color-scheme: dark)" href="/images/favicon-dark-180.png" sizes="180x180">
    <link rel="icon" media="(prefers-color-scheme: dark)" href="/images/favicon-dark-192.png" sizes="192x192">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  
  
    
<div id="banner" class="">
  <img src="/pic/wall.png" itemprop="image">
  <div id="banner-dim"></div>
</div>
 
   
  <div id="main-grid" class="shadow   ">
    <div id="nav" class=""  >
      <navbar id="navbar">
  <nav id="title-nav">
    <a href="/">
      <div id="vivia-logo">
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
      </div>
      <div>repr </div>
    </a>
  </nav>
  <nav id="main-nav">
    
      <a class="main-nav-link" href="/">Home</a>
    
      <a class="main-nav-link" href="/archives">Archives</a>
    
      <a class="main-nav-link" href="/about">About</a>
    
  </nav>
  <nav id="sub-nav">
    <a id="theme-btn" class="nav-icon">
      <span class="material-symbols-rounded light-mode-icon">wb_sunny</span>
      <span class="material-symbols-rounded dark-mode-icon">dark_mode</span>
    </a>
    
      <a id="nav-rss-link" class="nav-icon mobile-hide" href="/atom.xml" title="RSS Feed">
        <span class="material-symbols-rounded rss">rss_feed</span>
      </a>
    
    <a id="nav-search-btn" class="nav-icon" title="Search" style="display: none;">
      <span class="material-symbols-rounded">search</span>
    </a>
    <div id="nav-menu-btn" class="nav-icon">
      <span class="material-symbols-rounded">menu</span>
    </div>
  </nav>
</navbar>
<div id="nav-dropdown" class="hidden">
  <div id="dropdown-link-list">
    
      <a class="nav-dropdown-link" href="/">Home</a>
    
      <a class="nav-dropdown-link" href="/archives">Archives</a>
    
      <a class="nav-dropdown-link" href="/about">About</a>
    
    
      <a class="nav-dropdown-link" href="/atom.xml" title="RSS Feed">RSS</a>
     
    </div>
</div>
<script>
  let dropdownBtn = document.getElementById("nav-menu-btn");
  let dropdownEle = document.getElementById("nav-dropdown");
  dropdownBtn.onclick = function() {
    dropdownEle.classList.toggle("hidden");
  }
</script>
    </div>
    <div id="sidebar-wrapper">
      <sidebar id="sidebar">
  
    <div class="widget-wrap">
  <div class="info-card">
    <div class="avatar">
      
        <image src=https://cdn.discordapp.com/attachments/755522926819934349/1135933820852502589/chtholly_nota_seniorious_by_asukaln_dfhx63b-414w-2x.jpg></image>
      
      <div class="img-dim"></div>
    </div>
    <div class="info">
      <div class="username">nasm </div>
      <div class="dot"></div>
      <div class="subtitle">pwn / kernel stuff </div>
      <div class="link-list">
        
          <a class="link-btn" target="_blank" rel="noopener" href="https://twitter.com/nasm_re" title="Twitter"><i class="fa-brands fa-twitter"></i></a>
        
          <a class="link-btn" target="_blank" rel="noopener" href="https://github.com/n4sm" title="GitHub"><i class="fa-brands fa-github"></i></a>
        
          <a class="link-btn" target="_blank" rel="noopener" href="https://ret2school.github.io/discord" title="Discord"><i class="fa-brands fa-discord"></i></a>
         
      </div>  
    </div>
  </div>
</div>

  
  <div class="sticky">
    
      


  <div class="widget-wrap">
    <div class="widget">
      <h3 class="widget-title">Categories</h3>
      <div class="category-box">
            <a class="category-link" href="/categories/pwn/">
                pwn
                <div class="category-count">19</div>
            </a>
        
            <a class="category-link" href="/categories/kernel/">
                kernel
                <div class="category-count">3</div>
            </a>
        </div>
    </div>
  </div>


    
      
  <div class="widget-wrap">
    <div class="widget">
      <h3 class="widget-title">Recent Posts</h3>
      <ul>
        
          <a class="recent-link" href="/posts/iwindow/" title="[ImaginaryCTF 2023 - pwn] window-of-opportunity" >
            <div class="recent-link-text">
              [ImaginaryCTF 2023 - pwn] window-of-opportunity
            </div>
          </a>
        
          <a class="recent-link" href="/posts/mailman/" title="[ImaginaryCTF 2023 - pwn] mailman" >
            <div class="recent-link-text">
              [ImaginaryCTF 2023 - pwn] mailman
            </div>
          </a>
        
      </ul>
    </div>
  </div>

    
  </div>
</sidebar>
    </div>
    <div id="content-body">
       

<article id="post-lowlevelnotes" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
    
   
  <div class="article-inner">
    <div class="article-main">
      <header class="article-header">
        
<div class="main-title-bar">
  <div class="main-title-dot"></div>
  
    
      <h1 class="p-name article-title" itemprop="headline name">
        Linux kernel side notes
      </h1>
    
  
</div>

        <div class='meta-info-bar'>
          <div class="meta-info">
  <time class="dt-published" datetime="2022-07-17T22:00:00.000Z" itemprop="datePublished">2022-07-18</time>
</div>
          <div class="need-seperator meta-info">
            <div class="meta-cate-flex">
  
  <a class="meta-cate-link" href="/categories/kernel/">kernel</a>
   
</div>
  
          </div>
          <div class="wordcount need-seperator meta-info">
            1.2k words 
          </div>
        </div>
        
      </header>
      <div class="e-content article-entry" itemprop="articleBody">
        
          <p>Here are just some side notes about linux kernel internals I put here to avoid to have to learn same things again and again. Every notes target <a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.18.12/source/kernel">linux kernel 5.18.12</a>.<br>There will be a lot of code for which I do not comment the whole part.</p>
<h1 id="Kernel-heap-management-SLUB-SLAB-SLOB"><a href="#Kernel-heap-management-SLUB-SLAB-SLOB" class="headerlink" title="Kernel heap management (SLUB, SLAB, SLOB)"></a>Kernel heap management (SLUB, SLAB, SLOB)</h1><p>Same way as for userland, the kernel has many algorithms to manage memory allocation according to what the kernel is looking for (huge resources or not, safety needs etc).</p>
<h2 id="SLUB"><a href="#SLUB" class="headerlink" title="SLUB"></a>SLUB</h2><p>The SLUB algorithm is the algorithm I know the more, so that’s the one I will cover first. To allocate dynamically memory, the kernel provides the <code>kmalloc</code> function to which you can provide flags:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * kmalloc - allocate memory</span></span><br><span class="line"><span class="comment"> * @size: how many bytes of memory are required.</span></span><br><span class="line"><span class="comment"> * @flags: the type of memory to allocate.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * kmalloc is the normal method of allocating memory</span></span><br><span class="line"><span class="comment"> * for objects smaller than page size in the kernel.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The allocated object address is aligned to at least ARCH_KMALLOC_MINALIGN</span></span><br><span class="line"><span class="comment"> * bytes. For @size of power of two bytes, the alignment is also guaranteed</span></span><br><span class="line"><span class="comment"> * to be at least to the size.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The @flags argument may be one of the GFP flags defined at</span></span><br><span class="line"><span class="comment"> * include/linux/gfp.h and described at</span></span><br><span class="line"><span class="comment"> * :ref:`Documentation/core-api/mm-api.rst &lt;mm-api-gfp-flags&gt;`</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The recommended usage of the @flags is described at</span></span><br><span class="line"><span class="comment"> * :ref:`Documentation/core-api/memory-allocation.rst &lt;memory_allocation&gt;`</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Below is a brief outline of the most useful GFP flags</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * %GFP_KERNEL</span></span><br><span class="line"><span class="comment"> *	Allocate normal kernel ram. May sleep.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * %GFP_NOWAIT</span></span><br><span class="line"><span class="comment"> *	Allocation will not sleep.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * %GFP_ATOMIC</span></span><br><span class="line"><span class="comment"> *	Allocation will not sleep.  May use emergency pools.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * %GFP_HIGHUSER</span></span><br><span class="line"><span class="comment"> *	Allocate memory from high memory on behalf of user.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Also it is possible to set different flags by OR&#x27;ing</span></span><br><span class="line"><span class="comment"> * in one or more of the following additional @flags:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * %__GFP_HIGH</span></span><br><span class="line"><span class="comment"> *	This allocation has high priority and may use emergency pools.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * %__GFP_NOFAIL</span></span><br><span class="line"><span class="comment"> *	Indicate that this allocation is in no way allowed to fail</span></span><br><span class="line"><span class="comment"> *	(think twice before using).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * %__GFP_NORETRY</span></span><br><span class="line"><span class="comment"> *	If memory is not immediately available,</span></span><br><span class="line"><span class="comment"> *	then give up at once.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * %__GFP_NOWARN</span></span><br><span class="line"><span class="comment"> *	If allocation fails, don&#x27;t issue any warnings.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * %__GFP_RETRY_MAYFAIL</span></span><br><span class="line"><span class="comment"> *	Try really hard to succeed the allocation but fail</span></span><br><span class="line"><span class="comment"> *	eventually.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>What are the main structures of SLUB management ? This can be described by this picture for which we will review each of the data structures (pic from <a target="_blank" rel="noopener" href="https://programmersought.com/article/362810197389/">here</a>):</p>
<img align="center" width="100%" src="../../../SLUB_schema1.png">


<p>To cover the whole allocation process, we will review the main structures to then take a look at the actual allocation algorithm.<br>Given the complexity of such structures, each of these structures are treated in separate articles:</p>
<ul>
<li><a href="../kmem_cache">kmem_cache</a></li>
</ul>
<p>Let’s take a look at the source code of the <code>__kmalloc</code> SLUB implemementation:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://elixir.bootlin.com/linux/v5.18.12/source/mm/slub.c#L4399</span></span><br><span class="line"><span class="type">void</span> *__kmalloc(<span class="type">size_t</span> size, <span class="type">gfp_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">s</span>;</span></span><br><span class="line">	<span class="type">void</span> *ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(size &gt; KMALLOC_MAX_CACHE_SIZE))</span><br><span class="line">		<span class="keyword">return</span> kmalloc_large(size, flags);</span><br><span class="line"></span><br><span class="line">	s = kmalloc_slab(size, flags);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(ZERO_OR_NULL_PTR(s)))</span><br><span class="line">		<span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">	ret = slab_alloc(s, <span class="literal">NULL</span>, flags, _RET_IP_, size);</span><br><span class="line"></span><br><span class="line">	trace_kmalloc(_RET_IP_, ret, size, s-&gt;size, flags);</span><br><span class="line"></span><br><span class="line">	ret = kasan_kmalloc(s, ret, size, flags);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__kmalloc);</span><br></pre></td></tr></table></figure>

<h3 id="Large-allocations"><a href="#Large-allocations" class="headerlink" title="Large allocations"></a>Large allocations</h3><p>Thus, if the requested size is larger than <code>KMALLOC_MAX_CACHE_SIZE</code>, <code>kmalloc_large</code> is called, and <code>kmalloc_order</code> is called according to a particular <code>order</code>that represents the number of pages from the requested size:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://elixir.bootlin.com/linux/v5.18.12/source/mm/slab_common.c#L944</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * To avoid unnecessary overhead, we pass through large allocation requests</span></span><br><span class="line"><span class="comment"> * directly to the page allocator. We use __GFP_COMP, because we will need to</span></span><br><span class="line"><span class="comment"> * know the allocation order to free the pages properly in kfree.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">kmalloc_order</span><span class="params">(<span class="type">size_t</span> size, <span class="type">gfp_t</span> flags, <span class="type">unsigned</span> <span class="type">int</span> order)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">void</span> *ret = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(flags &amp; GFP_SLAB_BUG_MASK))</span><br><span class="line">		flags = kmalloc_fix_flags(flags);</span><br><span class="line"></span><br><span class="line">	flags |= __GFP_COMP;</span><br><span class="line">	page = alloc_pages(flags, order);</span><br><span class="line">	<span class="keyword">if</span> (likely(page)) &#123;</span><br><span class="line">		ret = page_address(page);</span><br><span class="line">		mod_lruvec_page_state(page, NR_SLAB_UNRECLAIMABLE_B,</span><br><span class="line">				PAGE_SIZE &lt;&lt; order);</span><br><span class="line">	&#125;</span><br><span class="line">	ret = kasan_kmalloc_large(ret, size, flags);</span><br><span class="line">	<span class="comment">/* As ret might get tagged, call kmemleak hook after KASAN. */</span></span><br><span class="line">	kmemleak_alloc(ret, size, <span class="number">1</span>, flags);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(kmalloc_order);</span><br></pre></td></tr></table></figure>

<p>The <code>__GFP_COMP</code> stands for the allocation of “compound pages”, to quote Jonathan Corbet from <a target="_blank" rel="noopener" href="https://lwn.net/Articles/619514/">this article</a>:</p>
<blockquote>
<p>A compound page is simply a grouping of two or more physically contiguous pages into a unit that can, in many ways, be treated as a single, larger page. They are most commonly used to create huge pages, used within hugetlbfs or the transparent huge pages subsystem, but they show up in other contexts as well. Compound pages can serve as anonymous memory or be used as buffers within the kernel; they cannot, however, appear in the page cache, which is only prepared to deal with singleton pages.</p>
</blockquote>
<p>The actual allocation is made in <code>alloc_pages</code>, more specifically in <code>__alloc_pages</code> that requests pages to the buddy allocator. But that’s out of scope for now. Thus what we know is that large allocations are handled directly by the buddy system.</p>
<h3 id="Small-allocations"><a href="#Small-allocations" class="headerlink" title="Small allocations"></a>Small allocations</h3><p>By following the other code path <code>kmalloc_slab</code> is called:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://elixir.bootlin.com/linux/v5.18.12/source/mm/slab_common.c#L730</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Find the kmem_cache structure that serves a given size of</span></span><br><span class="line"><span class="comment"> * allocation</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> kmem_cache *<span class="title function_">kmalloc_slab</span><span class="params">(<span class="type">size_t</span> size, <span class="type">gfp_t</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> index;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (size &lt;= <span class="number">192</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!size)</span><br><span class="line">			<span class="keyword">return</span> ZERO_SIZE_PTR;</span><br><span class="line"></span><br><span class="line">		index = size_index[size_index_elem(size)];</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (WARN_ON_ONCE(size &gt; KMALLOC_MAX_CACHE_SIZE))</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		index = fls(size - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> kmalloc_caches[kmalloc_type(flags)][index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="kmem-cache-init"><a href="#kmem-cache-init" class="headerlink" title="kmem_cache_init"></a>kmem_cache_init</h2><p><code>kmalloc_slab</code> returns the <code>kmalloc_cache</code> entry that matchs the provided flags and size. Let’s see how is initialized this array, the main initialization occurs in <code>kmem_cache_init</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">kmem_cache_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">static</span> __initdata <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> <span class="title">boot_kmem_cache</span>,</span></span><br><span class="line"><span class="class">			  <span class="title">boot_kmem_cache_node</span>;</span></span><br><span class="line">	<span class="type">int</span> node;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (debug_guardpage_minorder())</span><br><span class="line">		slub_max_order = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Print slub debugging pointers without hashing */</span></span><br><span class="line">	<span class="keyword">if</span> (__slub_debug_enabled())</span><br><span class="line">		no_hash_pointers_enable(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	kmem_cache_node = &amp;boot_kmem_cache_node;</span><br><span class="line">	kmem_cache = &amp;boot_kmem_cache;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Initialize the nodemask for which we will allocate per node</span></span><br><span class="line"><span class="comment">	 * structures. Here we don&#x27;t need taking slab_mutex yet.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	for_each_node_state(node, N_NORMAL_MEMORY)</span><br><span class="line">		node_set(node, slab_nodes);</span><br></pre></td></tr></table></figure>

<p><code>slab_nodes</code> is a <a target="_blank" rel="noopener" href="https://0xax.gitbooks.io/linux-insides/content/DataStructures/linux-datastructures-3.html">bitmap</a> representing the nodes used by the kernel. Given we’re on x86-64 the cpu is NUMA but behaves for compatibility purposes like a UMA system. Which means there is only one node used, and in it one “zone”: <code>N_NORMAL_MEMORY</code>. This way <code>for_each_node_state</code> loops only one time:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://elixir.bootlin.com/linux/latest/source/include/linux/nodemask.h#L482</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> for_each_node_state(node, __state) \</span></span><br><span class="line"><span class="meta">	for ( (node) = 0; (node) == 0; (node) = 1)</span></span><br></pre></td></tr></table></figure>
<p>This way <code>slab_nodes</code> is initialized to <code>1</code>.</p>
<p>Then the first two kmem_cache are created: <code>kmem_cache_node</code> and <code>kmem_cache</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">// https://elixir.bootlin.com/linux/latest/source/mm/slub.c#L4819</span></span><br><span class="line">	create_boot_cache(kmem_cache_node, <span class="string">&quot;kmem_cache_node&quot;</span>,</span><br><span class="line">		<span class="keyword">sizeof</span>(<span class="keyword">struct</span> kmem_cache_node), SLAB_HWCACHE_ALIGN, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	register_hotmemory_notifier(&amp;slab_memory_callback_nb);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Able to allocate the per node structures */</span></span><br><span class="line">	slab_state = PARTIAL;</span><br><span class="line"></span><br><span class="line">	create_boot_cache(kmem_cache, <span class="string">&quot;kmem_cache&quot;</span>,</span><br><span class="line">			offsetof(<span class="keyword">struct</span> kmem_cache, node) +</span><br><span class="line">				nr_node_ids * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> kmem_cache_node *),</span><br><span class="line">		       SLAB_HWCACHE_ALIGN, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	kmem_cache = bootstrap(&amp;boot_kmem_cache);</span><br><span class="line">	kmem_cache_node = bootstrap(&amp;boot_kmem_cache_node);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Now we can use the kmem_cache to allocate kmalloc slabs */</span></span><br><span class="line">	setup_kmalloc_cache_index_table();</span><br><span class="line">	create_kmalloc_caches(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Setup random freelists for each cache */</span></span><br><span class="line">	init_freelist_randomization();</span><br><span class="line"></span><br><span class="line">	cpuhp_setup_state_nocalls(CPUHP_SLUB_DEAD, <span class="string">&quot;slub:dead&quot;</span>, <span class="literal">NULL</span>,</span><br><span class="line">				  slub_cpu_dead);</span><br><span class="line"></span><br><span class="line">	pr_info(<span class="string">&quot;SLUB: HWalign=%d, Order=%u-%u, MinObjects=%u, CPUs=%u, Nodes=%u\n&quot;</span>,</span><br><span class="line">		cache_line_size(),</span><br><span class="line">		slub_min_order, slub_max_order, slub_min_objects,</span><br><span class="line">		nr_cpu_ids, nr_node_ids);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Let’s take a look at the main functions. But before that, let’s review the internal layout of the <code>kmem_cache</code> structure.</p>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/adera/p/11718758.html">cdnblogs, Allocation of mm-slab objects</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/linhaostudy/p/9992639.html">cdnblogs, Linux Memory Description of Memory Node Node - Linux Memory Management (II)</a></li>
<li><a target="_blank" rel="noopener" href="https://programmersought.com/article/362810197389/">programmerSought, Linux Memory Management SLUB Distributor 2 [Kmalloc_Cache Structure]</a></li>
<li><a target="_blank" rel="noopener" href="https://www.dingmos.com/index.php/archives/23/">dingmos, Linux kernel | Memory management - Slab allocator</a></li>
<li><a target="_blank" rel="noopener" href="https://wenqupro.com/?thread-20.htm">wenqupro, Article about kmem_cache</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_37637511/article/details/124960015">cdnblogs, Slub Allocator Learning Series Linux 5.10</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/458668727">zhuanlan, Non-professional understanding slub</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.birost.com/a?ID=01100-ba652270-a5d4-4038-91a9-e0c56bcc643b">Birost, Analysis of linux slub allocator</a></li>
<li><a target="_blank" rel="noopener" href="https://lwn.net/Articles/51437/">LWN, The zen of kobjects</a></li>
</ul>

        
      </div>

         
    </div>
    
     
  </div>
  
    
<nav id="article-nav">
  <a class="article-nav-btn left "
    
      href="/posts/catastrophe/"
      title="[diceCTF 2022 - pwn] catastrophe"
     >
    <i class="fa-solid fa-angle-left"></i>
    <p class="title-text">
      
        [diceCTF 2022 - pwn] catastrophe
        
    </p>
  </a>
  <a class="article-nav-btn right "
    
      href="/posts/kmem_cache/"
      title="[Linux kernel side notes - SLUB] kmem_cache"
     >

    <p class="title-text">
      
        [Linux kernel side notes - SLUB] kmem_cache
        
    </p>
    <i class="fa-solid fa-angle-right"></i>
  </a>
</nav>


  
</article>

 
    </div>
    <div id="footer-wrapper">
      <footer id="footer">
  
  <div id="footer-info" class="inner">
    
    &copy; 2023 nasm<br>
    Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> & Theme <a target="_blank" rel="noopener" href="https://github.com/saicaca/hexo-theme-vivia">Vivia</a>
  </div>
</footer>

    </div>
    <div class="back-to-top-wrapper">
    <button id="back-to-top-btn" class="back-to-top-btn hide" onclick="topFunction()">
        <span class="material-symbols-rounded">keyboard_arrow_up</span>
    </button>
</div>

<script>
    function topFunction() {
        window.scroll({ top: 0, behavior: 'smooth' });
    }
    let btn = document.getElementById('back-to-top-btn');
    function scrollFunction() {
        if (document.body.scrollTop > 600 || document.documentElement.scrollTop > 600) {
            btn.classList.remove('hide')
        } else {
            btn.classList.add('hide')
        }
    }
    window.onscroll = function() {
        scrollFunction();
    }
</script>

  </div>
  <script src="/js/light-dark-switch.js"></script>
</body>
</html>
